window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "lenapy", "modulename": "lenapy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "lenapy.constants", "modulename": "lenapy.constants", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "lenapy.constants.DAY_YEAR", "modulename": "lenapy.constants", "qualname": "DAY_YEAR", "kind": "variable", "doc": "<p></p>\n", "default_value": "365.24219"}, {"fullname": "lenapy.constants.SECONDS_DAY", "modulename": "lenapy.constants", "qualname": "SECONDS_DAY", "kind": "variable", "doc": "<p></p>\n", "default_value": "86400.0"}, {"fullname": "lenapy.constants.LNPY_RTER", "modulename": "lenapy.constants", "qualname": "LNPY_RTER", "kind": "variable", "doc": "<p></p>\n", "default_value": "6378137.0"}, {"fullname": "lenapy.constants.LNPY_f", "modulename": "lenapy.constants", "qualname": "LNPY_f", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.003352810682317694"}, {"fullname": "lenapy.constants.LNPY_SURFTER", "modulename": "lenapy.constants", "qualname": "LNPY_SURFTER", "kind": "variable", "doc": "<p></p>\n", "default_value": "510074897000000.0"}, {"fullname": "lenapy.filters", "modulename": "lenapy.filters", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "lenapy.filters.lanczos", "modulename": "lenapy.filters", "qualname": "lanczos", "kind": "function", "doc": "<p>Lanczos Filter\nImplementation of a filter whose spectral response is a door with a temporal width specified by \"cutoff\",\nconvoluted with anothe door narrower by a factor \"order\". Typicaly, a = 2 or 3. The filter is\ntruncated at +/- order * cutoff / 2.\nWith a higher order, the filter becomes close to a perfect sinc filter, but computation takes longer</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cutoff : integer\n    width of the temporal window (in samples)\norder : integer\n    order of the filter</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>filter : DataArray\n    Lanczos kernel</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">order</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.filters.moving_average", "modulename": "lenapy.filters", "qualname": "moving_average", "kind": "function", "doc": "<p>Moving average filter\nImplementation of a moving average filter, averaging values over \"npoints\" samples centered on the current point</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cutoff : integer\n    width of the temporal window (in samples)</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>filter : numpy array\n    moving_average kernel</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface", "modulename": "lenapy.interface", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.trouveNaN", "modulename": "lenapy.interface", "qualname": "trouveNaN", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.NCEI", "modulename": "lenapy.interface", "qualname": "NCEI", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.NCEI.__init__", "modulename": "lenapy.interface", "qualname": "NCEI.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span></span>)</span>"}, {"fullname": "lenapy.interface.NCEI.rep", "modulename": "lenapy.interface", "qualname": "NCEI.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.NCEI.nommage", "modulename": "lenapy.interface", "qualname": "NCEI.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">season</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.NCEI.ouvre", "modulename": "lenapy.interface", "qualname": "NCEI.ouvre", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fic</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.NCEI.charge", "modulename": "lenapy.interface", "qualname": "NCEI.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">season</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.SIO", "modulename": "lenapy.interface", "qualname": "SIO", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.SIO.__init__", "modulename": "lenapy.interface", "qualname": "SIO.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span></span>)</span>"}, {"fullname": "lenapy.interface.SIO.rep", "modulename": "lenapy.interface", "qualname": "SIO.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.SIO.nommage", "modulename": "lenapy.interface", "qualname": "SIO.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.SIO.charge", "modulename": "lenapy.interface", "qualname": "SIO.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">season</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.ISAS", "modulename": "lenapy.interface", "qualname": "ISAS", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ISAS.__init__", "modulename": "lenapy.interface", "qualname": "ISAS.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">release</span>, </span><span class=\"param\"><span class=\"n\">product</span><span class=\"o\">=</span><span class=\"s1\">&#39;ARGO&#39;</span></span>)</span>"}, {"fullname": "lenapy.interface.ISAS.rep", "modulename": "lenapy.interface", "qualname": "ISAS.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ISAS.release", "modulename": "lenapy.interface", "qualname": "ISAS.release", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ISAS.product", "modulename": "lenapy.interface", "qualname": "ISAS.product", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ISAS.nommage", "modulename": "lenapy.interface", "qualname": "ISAS.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.ISAS.charge", "modulename": "lenapy.interface", "qualname": "ISAS.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.ORAS5", "modulename": "lenapy.interface", "qualname": "ORAS5", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ORAS5.__init__", "modulename": "lenapy.interface", "qualname": "ORAS5.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span></span>)</span>"}, {"fullname": "lenapy.interface.ORAS5.rep", "modulename": "lenapy.interface", "qualname": "ORAS5.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ORAS5.nommage", "modulename": "lenapy.interface", "qualname": "ORAS5.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.ORAS5.charge", "modulename": "lenapy.interface", "qualname": "ORAS5.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.IPRC", "modulename": "lenapy.interface", "qualname": "IPRC", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.IPRC.__init__", "modulename": "lenapy.interface", "qualname": "IPRC.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span></span>)</span>"}, {"fullname": "lenapy.interface.IPRC.rep", "modulename": "lenapy.interface", "qualname": "IPRC.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.IPRC.nommage", "modulename": "lenapy.interface", "qualname": "IPRC.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.IPRC.charge", "modulename": "lenapy.interface", "qualname": "IPRC.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.ISHII", "modulename": "lenapy.interface", "qualname": "ISHII", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ISHII.__init__", "modulename": "lenapy.interface", "qualname": "ISHII.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span></span>)</span>"}, {"fullname": "lenapy.interface.ISHII.rep", "modulename": "lenapy.interface", "qualname": "ISHII.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ISHII.nommage", "modulename": "lenapy.interface", "qualname": "ISHII.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.ISHII.charge", "modulename": "lenapy.interface", "qualname": "ISHII.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.IAP", "modulename": "lenapy.interface", "qualname": "IAP", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.IAP.__init__", "modulename": "lenapy.interface", "qualname": "IAP.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span></span>)</span>"}, {"fullname": "lenapy.interface.IAP.rep", "modulename": "lenapy.interface", "qualname": "IAP.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.IAP.nommage", "modulename": "lenapy.interface", "qualname": "IAP.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.IAP.charge", "modulename": "lenapy.interface", "qualname": "IAP.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.JAMSTEC", "modulename": "lenapy.interface", "qualname": "JAMSTEC", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.JAMSTEC.__init__", "modulename": "lenapy.interface", "qualname": "JAMSTEC.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span></span>)</span>"}, {"fullname": "lenapy.interface.JAMSTEC.rep", "modulename": "lenapy.interface", "qualname": "JAMSTEC.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.JAMSTEC.nommage", "modulename": "lenapy.interface", "qualname": "JAMSTEC.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.JAMSTEC.charge", "modulename": "lenapy.interface", "qualname": "JAMSTEC.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.EN_422", "modulename": "lenapy.interface", "qualname": "EN_422", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.EN_422.__init__", "modulename": "lenapy.interface", "qualname": "EN_422.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">corr</span></span>)</span>"}, {"fullname": "lenapy.interface.EN_422.rep", "modulename": "lenapy.interface", "qualname": "EN_422.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.EN_422.corr", "modulename": "lenapy.interface", "qualname": "EN_422.corr", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.EN_422.nommage", "modulename": "lenapy.interface", "qualname": "EN_422.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.EN_422.charge", "modulename": "lenapy.interface", "qualname": "EN_422.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.ECCO", "modulename": "lenapy.interface", "qualname": "ECCO", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ECCO.__init__", "modulename": "lenapy.interface", "qualname": "ECCO.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span></span>)</span>"}, {"fullname": "lenapy.interface.ECCO.rep", "modulename": "lenapy.interface", "qualname": "ECCO.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.ECCO.charge", "modulename": "lenapy.interface", "qualname": "ECCO.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">month</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.ECCO.charge_mf", "modulename": "lenapy.interface", "qualname": "ECCO.charge_mf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">motif</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.LYMAN", "modulename": "lenapy.interface", "qualname": "LYMAN", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.LYMAN.__init__", "modulename": "lenapy.interface", "qualname": "LYMAN.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span></span>)</span>"}, {"fullname": "lenapy.interface.LYMAN.rep", "modulename": "lenapy.interface", "qualname": "LYMAN.rep", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.LYMAN.nommage", "modulename": "lenapy.interface", "qualname": "LYMAN.nommage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.LYMAN.charge", "modulename": "lenapy.interface", "qualname": "LYMAN.charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.interface.LEGOS", "modulename": "lenapy.interface", "qualname": "LEGOS", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.LEGOS.__init__", "modulename": "lenapy.interface", "qualname": "LEGOS.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">nom</span>, </span><span class=\"param\"><span class=\"n\">version</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "lenapy.interface.LEGOS.fic", "modulename": "lenapy.interface", "qualname": "LEGOS.fic", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.interface.charge", "modulename": "lenapy.interface", "qualname": "charge", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fichier</span>, </span><span class=\"param\"><span class=\"n\">lib</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.plotting", "modulename": "lenapy.plotting", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "lenapy.plotting.plot_timeseries_uncertainty", "modulename": "lenapy.plotting", "qualname": "plot_timeseries_uncertainty", "kind": "function", "doc": "<p>Affiche une s\u00e9rie temporelle avec une enveloppe d'incertitude.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : xr.DataArray, la s\u00e9rie temporelle que l'on veut plotter\nx_dim : la dimension qui sera sur l'axe des x. Par defaut on prend 'time'\ny_dim : la dimension qui permet de calculer l'incertitude\nthick_line : la m\u00e9trique afficher en ligne epaisse: \"median\" ou \"mean\"\nshaded_area : la m\u00e9trique qui permet de calculer l'incertitude: \"std\" ou \"quantiles\"\nquantile_min : si shaded_area=\"quantile\", la valeur du quantile inf\u00e9rieur (entre 0 et 1)\nquantile_max : si shaded_area=\"quantile\", la valeur du quantile sup\u00e9rieur (entre 0 et 1)\nthick_line_color : couleur de la ligne \u00e9paisse\nshaded_area_color : couleur de l'applat de couleur pour l'incertitude\nshaded_area_alpha : transparence de l'aplat de couleur pour l'incertitude\nadd_legend : bool, ajoute une legend</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">xgeo_data</span>,</span><span class=\"param\">\t<span class=\"n\">x_dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">y_dim</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">thick_line</span><span class=\"o\">=</span><span class=\"s1\">&#39;median&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">shaded_area</span><span class=\"o\">=</span><span class=\"s1\">&#39;quantiles&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">quantile_min</span><span class=\"o\">=</span><span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">quantile_max</span><span class=\"o\">=</span><span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">thick_line_color</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shaded_area_color</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shaded_area_alpha</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">label</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">line_kwargs</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">area_kwargs</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">add_legend</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits", "modulename": "lenapy.produits", "kind": "module", "doc": "<p>This module allows to load temperature and salinity data from different products and format the data with unified definition for variables and coordinates, compatible with the use of xOcean :\nstandardized coordinates names : latitude, longitude, depth, time\nstandardized variables names : temp or PT or CT for temperature, psal, SA, SR for salinity\nWhen loading a product, all the files present in the product directory are parsed. To gain computing time, a first filter on the years to load can be applied, as well as a text filter.\nA second date filter can be apply afterwards with the .sel(time=slice('begin_date','end_date') method.\nAll keyword arguments associated with xr.open_mfdataset can be passed.\nDask is implicitely used when using these interface methods.\nIt is strongly recommanded to chunk the dataset along depth dimension (chunks=dict(depth=10))</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing temperature and salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">ISAS</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/ISAS20&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"nb\">filter</span><span class=\"o\">=</span><span class=\"s1\">&#39;ARGO&#39;</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n"}, {"fullname": "lenapy.produits.rename_data", "modulename": "lenapy.produits", "qualname": "rename_data", "kind": "function", "doc": "<p>Standardization of coordinates names of a product\nLooks for different possible names for latitude, longitude, and time, and turn them into a standardized name :\n'lon','LON','Longitude','LONGITUDE' become 'longitude'\n'lat','LAT','Latitude','LATITUDE' become 'latitude'\n'date','dates','TIME','Time' become 'time'\nCustom names changes can also be performed with **kwargs parameter</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>**kwargs :  {old_name: new_name, ...}, optional\n    dictionnary specifying old names to be changed into new names</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>renamed : Dataset\n    New dataset containing modified names</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>ds=xr.open_mfdataset('product.nc',preprocess=rename_data)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.filtre_liste", "modulename": "lenapy.produits", "qualname": "filtre_liste", "kind": "function", "doc": "<p>Returns a filtered list of files fitting year range and pattern</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>files : Array of strings\n    Array with filenames to be filtered</p>\n\n<p>year : function\n    Function to be applied on each filename, returning the data year</p>\n\n<p>ymin : integer\n    Lowest bound of the time range</p>\n\n<p>ymax : integer\n    Highest bound of the time range</p>\n\n<p>pattern : string\n    Pattern that must fit the filenames</p>\n\n<h2 id=\"return\">Return</h2>\n\n<p>filtered : Array\n    Extract of th input array fitting year and pattern conditions</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">year</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">):</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>  <span class=\"k\">return</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;_&#39;</span><span class=\"p\">)[</span><span class=\"mi\">1</span><span class=\"p\">]</span> \n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fics</span><span class=\"o\">=</span><span class=\"n\">filtre_liste</span><span class=\"p\">(</span><span class=\"n\">glob</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">rep</span><span class=\"p\">,</span><span class=\"s1\">&#39;**&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;*.nc&#39;</span><span class=\"p\">)),</span><span class=\"n\">year</span><span class=\"p\">,</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"mi\">2006</span><span class=\"p\">,</span><span class=\"s1\">&#39;ARGO&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">files</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">ymin</span>, </span><span class=\"param\"><span class=\"n\">ymax</span>, </span><span class=\"param\"><span class=\"n\">pattern</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.ISAS", "modulename": "lenapy.produits", "qualname": "ISAS", "kind": "function", "doc": "<p>Load data from ISAS product\nProduct's directory must have the following format:\n-base directory (ex: ISAS20_ARGO)\n   |-year (ex: 2020)\n       |-release_type_timestamp_xxx_data.nc (ex: ISAS20_ARGO_20200915_fld_TEMP.nc)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing in-situ temperature and practical salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">ISAS</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/ISAS20&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"nb\">filter</span><span class=\"o\">=</span><span class=\"s1\">&#39;ARGO&#39;</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">9999</span>, </span><span class=\"param\"><span class=\"n\">filtre</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.NCEI", "modulename": "lenapy.produits", "qualname": "NCEI", "kind": "function", "doc": "<p>Load data from NCEI product\nTemperature and salinity are reconstructed from anomaly and trimestrial climatology</p>\n\n<p>Product's directory must have the following format:\n-base directory (ex: NCEI)\n   |-salinity\n       |-sanom_timestamp.nc (ex: sanom_C1C107-09.nc)\n   |-temperature\n       |-tanom_timestamp.nc (ex: tanom_C1C107-09.nc)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing in-situ temperature and practical salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">NCEI</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/NCEI&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">9999</span>, </span><span class=\"param\"><span class=\"n\">filtre</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.SIO", "modulename": "lenapy.produits", "qualname": "SIO", "kind": "function", "doc": "<p>Load data from SIO product.\nTemperature and salinity are reconstructed from anomaly and annual climatology, and depth coordinate is derived from pressure.</p>\n\n<p>Product's directory must have the following format:\n-base directory (ex: SIO)\n   |-climato\n       |-RG_ArgoClim_climato_release.nc (ex: RG_ArgoClim_climato_2004_2018.nc)\n   |-monthly\n       |-RG_ArgoClim_timestamp_release.nc (ex: RG_ArgoClim_202210_2019.nc)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing in-situ temperature and practical salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">SIO</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/SIO&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"nb\">filter</span><span class=\"o\">=</span><span class=\"s1\">&#39;ARGO&#39;</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">9999</span>, </span><span class=\"param\"><span class=\"n\">filtre</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.IPRC", "modulename": "lenapy.produits", "qualname": "IPRC", "kind": "function", "doc": "<p>Load data from IPRC product.</p>\n\n<p>Product's directory must have the following format:\n-base directory (ex: IPRC)\n   |-monthly\n       |-ArgoData_year_month.nc (ex: ArgoData_2020_01.nc)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing in-situ temperature and practical salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">IPRC</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/IPRC&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">9999</span>, </span><span class=\"param\"><span class=\"n\">filtre</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.ISHII", "modulename": "lenapy.produits", "qualname": "ISHII", "kind": "function", "doc": "<p>Load data from ISHII product.</p>\n\n<p>Product's directory must have the following format:\n-base directory (ex: ISHII)\n   |-monthly\n       |-xxx.year_month.nc (ex: sal.2022_08.nc)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing in-situ temperature and practical salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">ISHII</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/ISHII&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">9999</span>, </span><span class=\"param\"><span class=\"n\">filtre</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.IAP", "modulename": "lenapy.produits", "qualname": "IAP", "kind": "function", "doc": "<p>Load data from IAP product.</p>\n\n<p>Product's directory must have the following format:\n-base directory (ex: IAP)\n   |-sal\n       |-CZ16_depth_range_data_year_yyyy_month_mm.year_month.nc (ex: CZ16_1_2000m_salinity_year_2020_month_01.nc)\n   |-temp\n       |-CZ16_depth_range_data_year_yyyy_month_mm.year_month.nc (ex: CZ16_1_2000m_temperature_year_2020_month_01.nc)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing in-situ temperature and absolute salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">IAP</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/IAP&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">9999</span>, </span><span class=\"param\"><span class=\"n\">filtre</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.EN_422", "modulename": "lenapy.produits", "qualname": "EN_422", "kind": "function", "doc": "<p>Load data from EN product.</p>\n\n<p>Product's directory must have the following format:\n-base directory (ex: EN)\n   |-4.2.2.corr (ex : 4.2.2.g10)\n       |-EN.4.2.2.xxx.corr.timestamp.nc (ex: EN.4.2.2.f.analysis.g10.202108.nc)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\ncorr : {\"g10\",\"l09\",\"c13\",\"c14\"}\n    correction applyed\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing potential temperature and practical salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">EN_422</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/EN_422&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;c13&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">corr</span>, </span><span class=\"param\"><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">9999</span>, </span><span class=\"param\"><span class=\"n\">filtre</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.JAMSTEC", "modulename": "lenapy.produits", "qualname": "JAMSTEC", "kind": "function", "doc": "<p>Load data from JAMSTEC product.\nDepth coordinate is derived from pressure.</p>\n\n<p>Product's directory must have the following format:\n-base directory (ex: JAMSTEC)\n   |-monthly\n       |-TS_timestamp_xxx.nc (ex: TS_202105_GLB.nc)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing in-situ temperature and practical salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">JAMSTEC</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/JAMSTEC&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">9999</span>, </span><span class=\"param\"><span class=\"n\">filtre</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.produits.ECCO", "modulename": "lenapy.produits", "qualname": "ECCO", "kind": "function", "doc": "<p>Load data from ECCO product.</p>\n\n<p>Product's directory must have the following format:\n-base directory (ex: ECCO)\n   |-SALT\n       |-SALT_year_month.nc (ex: SALT_2016_12.nc)\n   |-THETA\n       |-THETA_year_month.nc (ex: THETA_2016_12.nc)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rep : string\n    path of the product's directory\nymin : int, optional\n    lowest bound of the time intervalle to be loaded (year)\nymax : int, optional\n    highest bound of the time intervalle to be loaded (year)\nfilter : string, optionnal\n    string pattern to filter datafiles names\n**kwargs :  optional\n    The keyword arguments form of open_mfdataset</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>product : Dataset\n    New dataset containing potential temperature and practical salinity data from the product</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">ECCO</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/usr/lenapy/data/ECCO&#39;</span><span class=\"p\">,</span><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">2005</span><span class=\"p\">,</span><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">2007</span><span class=\"p\">,</span><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;depth&#39;</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">sel</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"s1\">&#39;2005-06&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;2007-06&#39;</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">xocean</span><span class=\"o\">.</span><span class=\"n\">gohc</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rep</span>, </span><span class=\"param\"><span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mi\">9999</span>, </span><span class=\"param\"><span class=\"n\">filtre</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.sandbox", "modulename": "lenapy.sandbox", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "lenapy.sandbox.to_difgri", "modulename": "lenapy.sandbox", "qualname": "to_difgri", "kind": "function", "doc": "<p>difgri format use in gins tool is a non binary format with a specific number of columns and format should be %+13.6e\nfor example for 64800 values ( 1deg. x 1deg. ) there are 6480 lines sorted by row from left to right,\nstarting from longitude -179.5, latitude 89.5.\n(The first 360 values concern latitude 89.5, the next 360 latitude 88.5, etc.)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">dir_out</span>, </span><span class=\"param\"><span class=\"n\">prefix</span>, </span><span class=\"param\"><span class=\"n\">suffix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils", "modulename": "lenapy.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "lenapy.utils.filter", "modulename": "lenapy.utils", "qualname": "filter", "kind": "function", "doc": "<p>Filtre les donn\u00e9es en appliquant sur data le filtre filter_name, avec les param\u00e8tres d\u00e9finis dans **kwargs\nEffectue un miroir des donn\u00e9es au d\u00e9but et \u00e0 la fin pour \u00e9viter les effets de bords. Ce miroir est r\u00e9alis\u00e9\napr\u00e8s avoir retir\u00e9 un un polynome d'ordre q fittant au mieux les donn\u00e9es.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : xarray DataArray\n    Donn\u00e9es \u00e0 filtrer\nfilter_name : func (default=Lanczos)\n    nom de la fonction de filtrage\nq : integer (default=3)\n    ordre du polynome pour l'effet miroir (gestion des bords)\n**kwargs :\n    param\u00e8tres de la fonction de filtrage demand\u00e9e</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">filter_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;lanczos&#39;</span>, </span><span class=\"param\"><span class=\"n\">q</span><span class=\"o\">=</span><span class=\"mi\">3</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.isosurface", "modulename": "lenapy.utils", "qualname": "isosurface", "kind": "function", "doc": "<p>Linearly interpolate a coordinate isosurface where a field\nequals a target</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>field : xarray DataArray\n    The field in which to interpolate the target isosurface\ntarget : float\n    The target isosurface value\ndim : str\n    The field dimension to interpolate\ncoord : str (optional)\n    The field coordinate to interpolate. If absent, coordinate is supposed to be \"dim\"\nupper : bool\n    if True, returns the highest point of the isosurface, else the lowest</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<p>Calculate the depth of an isotherm with a value of 5.5:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">xr</span><span class=\"o\">.</span><span class=\"n\">DataArray</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>    <span class=\"n\">coords</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">&quot;depth&quot;</span><span class=\"p\">:</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)}</span>\n<span class=\"gp\">... </span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">isosurface</span><span class=\"p\">(</span><span class=\"n\">temp</span><span class=\"p\">,</span> <span class=\"mf\">5.5</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s2\">&quot;depth&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">&lt;xarray.DataArray ()&gt;</span>\n<span class=\"go\">array(4.5)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"n\">dim</span>, </span><span class=\"param\"><span class=\"n\">coord</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">upper</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.function_climato", "modulename": "lenapy.utils", "qualname": "function_climato", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span>, </span><span class=\"param\"><span class=\"n\">e</span>, </span><span class=\"param\"><span class=\"n\">f</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.climato", "modulename": "lenapy.utils", "qualname": "climato", "kind": "function", "doc": "<p>Analyse du cycle annuel, bi-annuel et de la tendance\nDecompose les donn\u00e9es en entr\u00e9e en :\n Un cycle annuel\n Un cycle bi-annuel\n Une tendance\n Une moyenne\n Un signal r\u00e9siduel\nRetourne la combinaison voulue de ces \u00e9l\u00e9ments en fonction des arguments choisis (signal, mean, trend, cycle)\nSi return_coeffs=True, retourne les coefficients des cycles et tendances</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>signal : Bool (default=True)\n    Renvoie le signal r\u00e9siduel apr\u00e8s retrait de la climato, de la tendance, et de la moyenne\nmean : Bool (default=True)\n    renvoie la valeur moyenne des donn\u00e9es d'entr\u00e9e\ntrend : Bool (default=True)\n    renvoie la tendance\ncycle : Bool (default=False)\n    renvoie le cycle annuel et bi-annuel\nreturn_coeffs : Bool (default=False)\n    retourne en plus les coefficients des cycles et de la tendance lin\u00e9aire</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">signal</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">mean</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">trend</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">cycle</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">return_coeffs</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.generate_climato", "modulename": "lenapy.utils", "qualname": "generate_climato", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">time</span>, </span><span class=\"param\"><span class=\"n\">coefficients</span>, </span><span class=\"param\"><span class=\"n\">mean</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">trend</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">cycle</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.trend", "modulename": "lenapy.utils", "qualname": "trend", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.interp_time", "modulename": "lenapy.utils", "qualname": "interp_time", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.to_datetime", "modulename": "lenapy.utils", "qualname": "to_datetime", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">input_type</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.diff_3pts", "modulename": "lenapy.utils", "qualname": "diff_3pts", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">dim</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.fill_time", "modulename": "lenapy.utils", "qualname": "fill_time", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.surface_cell", "modulename": "lenapy.utils", "qualname": "surface_cell", "kind": "function", "doc": "<p>Returns the earth surface of each cell defined by a longitude/latitude in a array\nCells limits are half distance between each given coordinate. That means that given coordinates are not necessary the center of each cell.\nBorder cells are supposed to have the same size on each side of the given coordinate.\nEx : coords=[1,2,4,7,9] ==&gt; cells size are [1,1.5,2.5,2.5,2]</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : dataarray or dataset\n    Must have latitude and longitude coordinates</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>surface : dataarray\n    dataarray with cells surface</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc')\n      surface = surface_cell(data)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.utils.ecarts", "modulename": "lenapy.utils", "qualname": "ecarts", "kind": "function", "doc": "<p>Return the width of each cells along specified coordinate.\nCells limits are half distance between each given coordinate. That means that given coordinates are not necessary the center of each cell.\nBorder cells are supposed to have the same size on each side of the given coordinate.\nEx : coords=[1,2,4,7,9] ==&gt; cells size are [1,1.5,2.5,2.5,2]</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : dataarray or dataset\n    Must have latitude and longitude coordinates</p>\n\n<p>dim : str\n    Coordinate along which to compute cell width</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>width : dataarray\n    dataarray with cell width for each coordinate</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">dim</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo", "modulename": "lenapy.xGeo", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "lenapy.xGeo.open_geodata", "modulename": "lenapy.xGeo", "qualname": "open_geodata", "kind": "function", "doc": "<p>Open a dataset base on xr.open_dataset method, while normalizing coordinates names and choosing NaN values</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>file : path\n    pathname of the file to open\n<em>args : optional\n    any arguments passed to open_dataset method\nrename : dict, optional\n    dictionnary {old_name:new_name,...}\nnan : optional\n    value to be replaced by NaN\nchunks : dict, optional\n    dictionnaty to perform chunks on data\ntime_type : str, optional\n    type used for time coordinate, used to convert to datetime64\n    possible values : 'frac_year' or '360_day'\n*</em>kwargs : optional\n    any keyword arguments passed to open_dataset method</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>data : Dataset\n    Dataset loaded from file</p>\n\n<h2 id=\"example\">Example</h2>\n\n<p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc')</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"n\">rename</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">nan</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">time_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.open_mfgeodata", "modulename": "lenapy.xGeo", "qualname": "open_mfgeodata", "kind": "function", "doc": "<p>Open a dataset base on xr.open_mfdataset method, while normalizing coordinates names and choosing NaN values</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>file : path\n    pattern fitting the file to open\n<em>args : optional\n    any arguments passed to open_dataset method\nrename : dict, optional\n    dictionnary {old_name:new_name,...}\nnan : optional\n    value to be replaced by NaN\nchunks : dict, optional\n    dictionnaty to perform chunks on data\ntime_type : str, optional\n    type used for time coordinate, used to convert to datetime64\n    possible values : 'frac_year' or '360_day'\n*</em>kwargs : optional\n    any keyword arguments passed to open_dataset method</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>data : Dataset\n    Dataset loaded from file</p>\n\n<h2 id=\"example\">Example</h2>\n\n<p>data = xgeo.open_mfgeodata('/home/user/lenapy/data/gohc_*.nc')</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fic</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"n\">rename</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">nan</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">time_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.open_mask", "modulename": "lenapy.xGeo", "qualname": "open_mask", "kind": "function", "doc": "<p>Open a mask in a dataset file, choose a given field, and regrid according to a given geometry. \nThe returned mask contains an extra dimension named 'zone', corresponding to the different values\nof the mask contained in the opened dataset.\nRequired format for the dataset to be opened :</p>\n\n<ul>\n<li>contains several dataarrays, each one being a mask (identified as 'field')</li>\n<li>each mask is defined by values, whose signification is given in the attributes of the dataarray : {'value1' : 'label1',...}</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>file : path\n    path and filename of the mask file to be opened\nfield : string\n    name of the data to be used as a mask in the dataset\ngrid : dataset, optional\n    dataset to be regridded on. If None, no regridding is performed</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mask : DataArray\n    DataArray with regridded mask</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">xgeo</span><span class=\"o\">.</span><span class=\"n\">open_mask</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/user/lenapy/data/mask/GEO_mask_1deg_20210406.nc&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;mask_continents&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mask</span><span class=\"o\">.</span><span class=\"n\">zone</span>\n<span class=\"go\">&lt;xarray.DataArray (latitude: 360, longitude: 720, zone: 9)&gt;</span>\n<span class=\"go\">    array([[[False,  True, False, ..., False, False, False],</span>\n<span class=\"go\">    ...</span>\n<span class=\"go\">            [False, False, False, ..., False, False, False]]])</span>\n<span class=\"go\">    Coordinates:</span>\n<span class=\"go\">      * longitude  (longitude) float64 -179.8 -179.2 -178.8 ... 178.8 179.2 179.8</span>\n<span class=\"go\">      * latitude   (latitude) float64 -89.75 -89.25 -88.75 ... 88.75 89.25 89.75</span>\n<span class=\"go\">      * zone       (zone) &lt;U18 &#39;Greenland&#39; &#39;Antarctica&#39; ... &#39;Maritime continent&#39;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span>, </span><span class=\"param\"><span class=\"n\">field</span>, </span><span class=\"param\"><span class=\"n\">grid</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet", "modulename": "lenapy.xGeo", "qualname": "GeoSet", "kind": "class", "doc": "<p>This class implements an extension of any dataset to add some usefull methods often used in earth science data handling</p>\n"}, {"fullname": "lenapy.xGeo.GeoSet.__init__", "modulename": "lenapy.xGeo", "qualname": "GeoSet.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xarray_obj</span></span>)</span>"}, {"fullname": "lenapy.xGeo.GeoSet.climato", "modulename": "lenapy.xGeo", "qualname": "GeoSet.climato", "kind": "function", "doc": "<p>Perform climato analysis on all the variables in a dataset\nInput data are decomposed into :\n    annual cycle\n    semi-annual cycle\n    trend\n    mean\n    residual signal\nThe returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)\nIf return_coeffs=True, the coefficients of the decompositions are returned</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>signal : Bool (default=True)\n    returns residual signal\nmean : Bool (default=True)\n    returns mean signal\ntrend : Bool (default=True)\n    returns trend\ncycle : Bool (default=False)\n    return annual and semi-annual cycles\nreturn_coeffs : Bool (default=False)\n    returns cycle coefficient, mean and trend\n    retourne en plus les coefficients des cycles et de la tendance lin\u00e9aire</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>climato : dataset\n    a dataset with the same structure as the input, with modified data according to the chosen options\nif return_coeffs=True, an extra dataset is provided with the coefficients of the decomposition</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc')\n      output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.mean", "modulename": "lenapy.xGeo", "qualname": "GeoSet.mean", "kind": "function", "doc": "<p>Returns the averaged value of all variables in dataset along specified dimension, applying specified weights</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>*args : list\n    list of the dimensions along which to average</p>\n\n<p>weights : None or list or dataarray\n    if None, no weight is applyed\n    if 'latitude' or 'depth', a weight is applyed as the cosine of the latitude or \n            the thickness of the layer\n    if dataarray :\n            input data are multiplied by this dataarray before averaging\nmask : None or dataarray\n    mask to be applyed befire averaging\nna_eq_zero : boolean (default=False)\n    replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones\n**kwargs : keyword arguments\n    any keyword arguments passe to the native xarray.mean function</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>averaged : dataset\n    dataset with all variables averaged according to specified options</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc')\n      avg = data.xgeo.mean(['latitude','longitude'],weights=['latitude'],na_eq_zero=True)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.sum", "modulename": "lenapy.xGeo", "qualname": "GeoSet.sum", "kind": "function", "doc": "<p>Returns the sum for all variables in dataset along specified dimension, applying specified weights</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>*args : list\n    list of the dimensions along which to sum</p>\n\n<p>weights : None or list or dataarray\n    if None, no weight is applyed\n    if 'latitude' or 'depth', a weight is applyed as the cosine of the latitude or \n            the thickness of the layer\n    if dataarray :\n            input data are multiplied by this dataarray before summing\nmask : None or dataarray\n    mask to be applyed before summing\n**kwargs : keyword arguments\n    any keyword arguments passe to the native xarray.sum function</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>averaged : dataset\n    dataset with all variablessummed according to specified options</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc')\n      avg = data.xgeo.sum(['latitude','longitude'],weights=['latitude'])</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.isosurface", "modulename": "lenapy.xGeo", "qualname": "GeoSet.isosurface", "kind": "function", "doc": "<p>Compute the isosurface along the specified coordinate at the value defined  by the kwarg field=value.\nFor example, we want to compute the isosurface defined by a temperature of 10\u00b0C along depth dimension.\nAll data variables of the data set are interpolated on this iso surface\nData is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,\nstarting from the end (bottom) if upper=False, or from the beggining (top) if upper=True</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>criterion : dict\n    one-entry dictionnary with the key equal to a variable of the dataset, and the value equal to the isosurface criterion\ndim : string\n    dimension along which to compute the isosurface\ncoord : str (optional)\n    The field coordinate to interpolate. If absent, coordinate is supposed to be \"dim\"\nupper : boolean (default=False)\n    order to perform the research of the criterion value. If False, from the end, if True, form the beggining</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>isosurface : dataset\n    Dataset with all the variables interpolated at the criterion value along chosen dimension. The variables chosen for\n        criterion should contain a constant value equal to the criterion. the dimension chosen for the isosurface computation\n        is filled with the isosurface itself.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc')\n      data.isosurface('depth',dict(temp=3))\n      <xarray.Dataset>\n      Dimensions:    (latitude: 90, longitude: 180)\n      Coordinates:</p>\n      \n      <ul>\n      <li>latitude   (latitude) float32 -44.5 -43.5 -42.5 -41.5 ... 42.5 43.5 44.5</li>\n      <li>longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 177.0 178.0 179.0 180.0\n      time       datetime64[ns] 2005-01-15\n      depth      (latitude, longitude) float64 918.6 745.8 704.8 ... 912.2 920.0\n      Data variables:\n      depth_iso  (latitude, longitude) float64 918.6 745.8 704.8 ... 912.2 920.0\n      temp       (latitude, longitude) float64 3.0 3.0 3.0 3.0 ... 3.0 3.0 3.0 3.0\n      SA         (latitude, longitude) float64 34.48 34.39 34.39 ... 34.53 34.52</li>\n      </ul>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">criterion</span>, </span><span class=\"param\"><span class=\"n\">dim</span>, </span><span class=\"param\"><span class=\"n\">coord</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">upper</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.regridder", "modulename": "lenapy.xGeo", "qualname": "GeoSet.regridder", "kind": "function", "doc": "<p>Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataset \ncoordinates to gr_out coordinates</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>gr_out : dataset\n    dataset containing the coordinates to regrid on\n*args : \n    any argument passed to xesmf.Regridder method\nmask_in : None or dataarray\n    mask to be applied on the data to regrid\nmethod : str\n    resampling method (see xesmf documentation) <br />\n*kwargs : \n    any keyword argument passed to xesmf.Regridder method</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>regridder : xesmf.Regridder instance\n    regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">gr_out</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">mask_in</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.regrid", "modulename": "lenapy.xGeo", "qualname": "GeoSet.regrid", "kind": "function", "doc": "<p>Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>regridder : xesmf.Regridder instance\n    regridder set with the xgeo.regridder method\n*args : \n    any argument passed to xesmf regridder method\n*kwargs : \n    any keyword argument passed to xesmf regridder method</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>regrid : dataset\n    dataset regridded to gr_out coordinates</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>ds_out = xr.Dataset({\"latitude\":([\"latitude\"],np.arange(-89.5,90,1.)),</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span>                    <span class=\"s2\">&quot;longitude&quot;</span><span class=\"p\">:([</span><span class=\"s2\">&quot;longitude&quot;</span><span class=\"p\">],</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">179.5</span><span class=\"p\">,</span><span class=\"mi\">180</span><span class=\"p\">,</span><span class=\"mf\">1.</span><span class=\"p\">))})</span>\n<span class=\"go\">&gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&quot;conservative_normed&quot;,periodic=True)</span>\n<span class=\"go\">&gt;&gt;&gt;out = data.xgeo.regrid(regridder)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">regridder</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.filter", "modulename": "lenapy.xGeo", "qualname": "GeoSet.filter", "kind": "function", "doc": "<p>Apply a specified filter on all the time-dependent data in the dataset\nBoundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data\nAvailable filters are in the .utils python file</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>filter_name : function or string\n    if string, filter function name, from the .filters file\n    if function, external function defined by user, returning a kernel\nq : int\n    order of the polyfit to handle boundary effects\n**kwargs :\n    keyword arguments for the chosen filter</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>filtered : filtered dataset</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc')\n      data.xgeo.filter(lanczos,q=3,coupure=12,order=2)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filter_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;lanczos&#39;</span>, </span><span class=\"param\"><span class=\"n\">q</span><span class=\"o\">=</span><span class=\"mi\">3</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.interp_time", "modulename": "lenapy.xGeo", "qualname": "GeoSet.interp_time", "kind": "function", "doc": "<p>Interpolate dataarray at the same dates than other</p>\n\n<h2 id=\"parameter\">Parameter</h2>\n\n<p>other : dataarray\n    must have a time dimension</p>\n\n<h2 id=\"return\">Return</h2>\n\n<p>interpolated : dataarray\n    new dataarray interpolated</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.to_datetime", "modulename": "lenapy.xGeo", "qualname": "GeoSet.to_datetime", "kind": "function", "doc": "<p>Convert dataset time format to standard pandas time format</p>\n\n<h2 id=\"parameter\">Parameter</h2>\n\n<p>input_type : string\n    Can be 'frac_year' or '360_day'</p>\n\n<h2 id=\"return\">Return</h2>\n\n<p>converted : dataset\n    new dataset with the time dimension in a standard pandas format</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">input_type</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.fill_time", "modulename": "lenapy.xGeo", "qualname": "GeoSet.fill_time", "kind": "function", "doc": "<p>Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN\nbut real absent points in the timeseries. A linear interpolation is performed at the missing points.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoSet.surface_cell", "modulename": "lenapy.xGeo", "qualname": "GeoSet.surface_cell", "kind": "function", "doc": "<p>Returns the earth surface of each cell defined by a longitude/latitude in a array\nCells limits are half distance between each given coordinate. That means that given coordinates are not necessary the center of each cell.\nBorder cells are supposed to have the same size on each side of the given coordinate.\nEx : coords=[1,2,4,7,9] ==&gt; cells size are [1,1.5,2.5,2.5,2]</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>surface : dataarray\n    dataarray with cells surface</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc')\n      surface = data.xgeo.surface_cell()</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray", "modulename": "lenapy.xGeo", "qualname": "GeoArray", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "lenapy.xGeo.GeoArray.__init__", "modulename": "lenapy.xGeo", "qualname": "GeoArray.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xarray_obj</span></span>)</span>"}, {"fullname": "lenapy.xGeo.GeoArray.climato", "modulename": "lenapy.xGeo", "qualname": "GeoArray.climato", "kind": "function", "doc": "<p>Perform climato analysis on a dataarray\nInput data are decomposed into :\n    annual cycle\n    semi-annual cycle\n    trend\n    mean\n    residual signal\nThe returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)\nIf return_coeffs=True, the coefficients of the decompositions are returned</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>signal : Bool (default=True)\n    returns residual signal\nmean : Bool (default=True)\n    returns mean signal\ntrend : Bool (default=True)\n    returns trend\ncycle : Bool (default=False)\n    return annual and semi-annual cycles\nreturn_coeffs : Bool (default=False)\n    returns cycle coefficient, mean and trend\n    retourne en plus les coefficients des cycles et de la tendance lin\u00e9aire</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>climato : dataarray\n    a dataarray with the same structure as the input, with modified data according to the chosen options\nif return_coeffs=True, an extra dataset is provided with the coefficients of the decomposition</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc').ohc\n      output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.mean", "modulename": "lenapy.xGeo", "qualname": "GeoArray.mean", "kind": "function", "doc": "<p>Returns the averaged value of dataarray along specified dimension, applying specified weights</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>*args : list\n    list of the dimensions along which to average</p>\n\n<p>weights : None or list or dataarray\n    if None, no weight is applyed\n    if 'latitude' or 'depth', a weight is applyed as the cosine of the latitude or \n            the thickness of the layer\n    if dataarray :\n            input data are multiplied by this dataarray before averaging\nmask : None or dataarray\n    mask to be applyed before averaging\nna_eq_zero : boolean (default=False)\n    replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones\n**kwargs : keyword arguments\n    any keyword arguments passe to the native xarray.mean function</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>averaged : dataarray\n    dataarray averaged according to specified options</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc').temp\n      avg = data.xgeo.mean(['latitude','longitude'],weights=['latitude'],na_eq_zero=True)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">na_eq_zero</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.sum", "modulename": "lenapy.xGeo", "qualname": "GeoArray.sum", "kind": "function", "doc": "<p>Returns the sum of dataarray along specified dimension, applying specified weights</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>*args : list\n    list of the dimensions along which to sum</p>\n\n<p>weights : None or list or dataarray\n    if None, no weight is applyed\n    if 'latitude' or 'depth', a weight is applyed as the cosine of the latitude or \n            the thickness of the layer\n    if dataarray :\n            input data are multiplied by this dataarray before summing\nmask : None or dataarray\n    mask to be applyed before summing\n**kwargs : keyword arguments\n    any keyword arguments passe to the native xarray.sum function</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>averaged : dataarray\n    dataarray summed according to specified options</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc').heat\n      avg = data.xgeo.sum(['latitude','longitude'],weights=['latitude'])</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.isosurface", "modulename": "lenapy.xGeo", "qualname": "GeoArray.isosurface", "kind": "function", "doc": "<p>Compute the isosurface along the specified coordinate at the value defined  by the target.\nData is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,\nstarting from the end (bottom) if upper=False, or from the beggining (top) if upper=True</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>target : float\n    criterion value to be satisfied at the iso surface\ndim : string\n    dimension along which to compute the isosurface\ncoord : str (optional)\n    The field coordinate to interpolate. If absent, coordinate is supposed to be \"dim\"\nupper : boolean (default=False)\n    order to perform the research of the criterion value. If False, from the end, if True, form the beggining</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>isosurface : dataarray\n    Dataarray containing the isosurface along the dimension dim on which data=target.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc').temp\n      data.isosurface(3,'depth')\n      <xarray.DataArray (latitude: 90, longitude: 180)&gt;\n      dask.array&lt;_nanmax_skip-aggregate, shape=(90, 180), dtype=float64, chunksize=(90, 180), chunktype=numpy.ndarray>\n      Coordinates:</p>\n      \n      <ul>\n      <li>latitude   (latitude) float32 -44.5 -43.5 -42.5 -41.5 ... 42.5 43.5 44.5</li>\n      <li>longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 177.0 178.0 179.0 180.0\n      time       datetime64[ns] 2005-01-15</li>\n      </ul>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"n\">dim</span>, </span><span class=\"param\"><span class=\"n\">coord</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">upper</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.regridder", "modulename": "lenapy.xGeo", "qualname": "GeoArray.regridder", "kind": "function", "doc": "<p>Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataarray \ncoordinates to gr_out coordinates</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>gr_out : dataset\n    dataset containing the coordinates to regrid on\n*args : \n    any argument passed to xesmf.Regridder method\nmask_in : None or dataarray\n    mask to be applied on the data to regrid\nmethod : str\n    resampling method (see xesmf documentation) <br />\n*kwargs : \n    any keyword argument passed to xesmf.Regridder method</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>regridder : xesmf.Regridder instance\n    regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">gr_out</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">mask_in</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.regrid", "modulename": "lenapy.xGeo", "qualname": "GeoArray.regrid", "kind": "function", "doc": "<p>Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>regridder : xesmf.Regridder instance\n    regridder set with the xgeo.regridder method</p>\n\n<p>*args : \n    any argument passed to xesmf regridder method\n*kwargs : \n    any keyword argument passed to xesmf regridder method</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>regrid : dataset\n    dataset regridded to gr_out coordinates</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>ds_out = xr.Dataset({\"latitude\":([\"latitude\"],np.arange(-89.5,90,1.)),</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span>                    <span class=\"s2\">&quot;longitude&quot;</span><span class=\"p\">:([</span><span class=\"s2\">&quot;longitude&quot;</span><span class=\"p\">],</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">179.5</span><span class=\"p\">,</span><span class=\"mi\">180</span><span class=\"p\">,</span><span class=\"mf\">1.</span><span class=\"p\">))})</span>\n<span class=\"go\">&gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&quot;conservative_normed&quot;,periodic=True)</span>\n<span class=\"go\">&gt;&gt;&gt;out = data.xgeo.regrid(regridder)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">regridder</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.filter", "modulename": "lenapy.xGeo", "qualname": "GeoArray.filter", "kind": "function", "doc": "<p>Apply a specified filter on all the time-dependent datarray\nBoundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data\nAvailable filters are in the .utils python file</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>filter_name : function or string\n    if string, filter function name, from the .filters file\n    if function, external function defined by user, returning a kernel\nq : int\n    order of the polyfit to handle boundary effects\n**kwargs :\n    keyword arguments for the chosen filter</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>filtered : filtered dataset</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc').temp\n      data.xgeo.filter(lanczos,q=3,coupure=12,order=2)</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filter_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;lanczos&#39;</span>, </span><span class=\"param\"><span class=\"n\">q</span><span class=\"o\">=</span><span class=\"mi\">3</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.interp_time", "modulename": "lenapy.xGeo", "qualname": "GeoArray.interp_time", "kind": "function", "doc": "<p>Interpolate dataarray at the same dates than other</p>\n\n<h2 id=\"parameter\">Parameter</h2>\n\n<p>other : dataarray\n    must have a time dimension</p>\n\n<h2 id=\"return\">Return</h2>\n\n<p>interpolated : dataarray\n    new dataarray interpolated</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.plot_timeseries_uncertainty", "modulename": "lenapy.xGeo", "qualname": "GeoArray.plot_timeseries_uncertainty", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.to_datetime", "modulename": "lenapy.xGeo", "qualname": "GeoArray.to_datetime", "kind": "function", "doc": "<p>Convert dataarray time format to standard pandas time format</p>\n\n<h2 id=\"parameter\">Parameter</h2>\n\n<p>input_type : string\n    Can be 'frac_year' or '360_day'</p>\n\n<h2 id=\"return\">Return</h2>\n\n<p>converted : dataarray\n    new dataarray with the time dimension in a standard pandas format</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">input_type</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.diff_3pts", "modulename": "lenapy.xGeo", "qualname": "GeoArray.diff_3pts", "kind": "function", "doc": "<p>Derivative formula along the selected dimension, returning on each point the linear regression on the three points\ndefined by the selected point and its two neighbours</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dim</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.to_difgri", "modulename": "lenapy.xGeo", "qualname": "GeoArray.to_difgri", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dir_out</span>, </span><span class=\"param\"><span class=\"n\">prefix</span>, </span><span class=\"param\"><span class=\"n\">suffix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.trend", "modulename": "lenapy.xGeo", "qualname": "GeoArray.trend", "kind": "function", "doc": "<p>Perform a linear regression on the data, and returns the slope coefficient</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.fill_time", "modulename": "lenapy.xGeo", "qualname": "GeoArray.fill_time", "kind": "function", "doc": "<p>Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN\nbut real absent points in the timeseries. A linear interpolation is performed at the missing points.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xGeo.GeoArray.surface_cell", "modulename": "lenapy.xGeo", "qualname": "GeoArray.surface_cell", "kind": "function", "doc": "<p>Returns the earth surface of each cell defined by a longitude/latitude in a array\nCells limits are half distance between each given coordinate. That means that given coordinates are not necessary the center of each cell.\nBorder cells are supposed to have the same size on each side of the given coordinate.\nEx : coords=[1,2,4,7,9] ==&gt; cells size are [1,1.5,2.5,2.5,2]</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>surface : dataarray\n    dataarray with cells surface</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc')\n      surface = data.xgeo.surface_cell()</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xOcean", "modulename": "lenapy.xOcean", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.proprietes", "modulename": "lenapy.xOcean", "qualname": "proprietes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da</span>, </span><span class=\"param\"><span class=\"n\">nom</span>, </span><span class=\"param\"><span class=\"n\">label</span>, </span><span class=\"param\"><span class=\"n\">unite</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xOcean.NoneType", "modulename": "lenapy.xOcean", "qualname": "NoneType", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">var</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xOcean.OceanSet", "modulename": "lenapy.xOcean", "qualname": "OceanSet", "kind": "class", "doc": "<p>This class extends any dataset to a xOcean object, that allows to access to any TEOS10 variable simply by calling the name of the variable through the xOcean interface.\nThe initial dataset must contains the fields necessary to compute the output variable (ex : temperature and salinity to compute heat, heat to compute ohc,...)</p>\n\n<h2 id=\"availabe-fields\">Availabe fields</h2>\n\n<p>Temperatures : one of the three types of temperature must be present in the original dataset to perform derived computation.\n    temp  : in-situ temperature <br />\n    PT    : potential temperature <br />\n    CT    : conservative temperature </p>\n\n<p>Salinities :  one of the three types of salinities must be present in the original dataset to perform derived computation.\n    psal  : practical salinity <br />\n    SR    : relative salinity <br />\n    SA    : absolute salinity. If there is no location information (lat,lon), absolute salinity is returned equal to relative salinity</p>\n\n<p>Physical properties :\n    P     : pressure. If location information is present, pressure is adjusted with regard to latitude, otherwise latitude is equal to 0\n    Cp    : heat capacity\n    rho   : density\n    sigma0: potential density anomaly at 0 dbar</p>\n\n<p>Heat content :\n    heat  : specific heat content (J/m3)\n    ohc   : local ocean heat content (J/m\u00b2), it is heat integrated over the whole ocean depth\n    gohc  : global ocean heat content (J/m\u00b2), it is ohc averaged over latitude-longitude, excluding continents\n    gohc_TOA: idem gohc, including continents (where ohc=0)\n    ohc_above: idem ohc, where heat is integrated above a given depth\n    gohc_above: idem gohc, averaging ohc_above instead of ohc</p>\n\n<p>Sea level :\n    slh   : steric sea layer height anomaly (-), equal to (1. - rho/rhoref)\n    ssl   : steric sea surface level anomaly (m), it is slh integrated over the whole ocean depth\n    ieeh  : integrated expansion efficiency oh heat (m/(J/m\u00b2)), it is (ssl/ohc)</p>\n\n<p>Layer depth :\n    ocean_depth  : maximum depth with non Nan values for temperature\n    mld_theta0   : ocean mixed layer depth, defined by a temperature drop from 0.2\u00b0C wrt to -10m depth \n    mld_sigma0   : ocean mixed layer depth, defined by a potential density increase of 0.03kg/m3 wrt to -10m depth\n    mld_sigma0var: ocean mixed layer depth, defined by a potential density equal to the potential density at -10m depth with a temperature dropped by 0.2\u00b0C</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data=IAP('/home/usr/lenapy/data/IAP')\n      print(data)\n      <xarray.Dataset>\n      Dimensions:    (latitude: 180, longitude: 360, time: 156, depth: 41)\n      Coordinates:</p>\n      \n      <ul>\n      <li>latitude   (latitude) float32 -89.5 -88.5 -87.5 -86.5 ... 87.5 88.5 89.5</li>\n      <li>longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 357.0 358.0 359.0 360.0</li>\n      <li>time       (time) datetime64[ns] 2005-01-15 2005-02-15 ... 2017-12-15</li>\n      <li>depth      (depth) float32 1.0 5.0 10.0 20.0 ... 1.7e+03 1.8e+03 2e+03\n      Data variables:\n      temp       (time, latitude, longitude, depth) float32 dask.array<chunksize=(1, 180, 360, 10), meta=np.ndarray>\n      SA         (time, latitude, longitude, depth) float32 dask.array<chunksize=(1, 180, 360, 10), meta=np.ndarray>\n      mld=data.xocean.mld_sigma0\n      print(data.xocean.ohc_above(mld))\n      <xarray.DataArray 'ohc_above' (time: 156, latitude: 180, longitude: 360)&gt;\n      dask.array<where, shape=(156, 180, 360), dtype=float64, chunksize=(1, 180, 360), chunktype=numpy.ndarray>\n      Coordinates:\n      depth      (time, latitude, longitude) float64 dask.array<chunksize=(1, 180, 360), meta=np.ndarray></li>\n      <li>time       (time) datetime64[ns] 2005-01-15 2005-02-15 ... 2017-12-15</li>\n      <li>latitude   (latitude) float32 -89.5 -88.5 -87.5 -86.5 ... 87.5 88.5 89.5</li>\n      <li>longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 357.0 358.0 359.0 360.0\n      Attributes:\n      long_name:  Ocean heat content\n      units:      J/m\u00b2\n      print(data.xocean.gohc)\n      <xarray.DataArray 'gohc' (time: 156)&gt;\n      dask.array<truediv, shape=(156,), dtype=float64, chunksize=(1,), chunktype=numpy.ndarray>\n      Coordinates:</li>\n      <li>time     (time) datetime64[ns] 2005-01-15 2005-02-15 ... 2017-12-15\n      depth    float32 1.0\n      Attributes:\n      long_name:  Global ocean heat content wrt to ocean surface area\n      units:      J/m\u00b2</li>\n      </ul>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "bases": "lenapy.xGeo.GeoSet"}, {"fullname": "lenapy.xOcean.OceanSet.__init__", "modulename": "lenapy.xOcean", "qualname": "OceanSet.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xarray_obj</span></span>)</span>"}, {"fullname": "lenapy.xOcean.OceanSet.oml_theta0_threshold", "modulename": "lenapy.xOcean", "qualname": "OceanSet.oml_theta0_threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.oml_sigma0_threshold", "modulename": "lenapy.xOcean", "qualname": "OceanSet.oml_sigma0_threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.temp", "modulename": "lenapy.xOcean", "qualname": "OceanSet.temp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.PT", "modulename": "lenapy.xOcean", "qualname": "OceanSet.PT", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.CT", "modulename": "lenapy.xOcean", "qualname": "OceanSet.CT", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.psal", "modulename": "lenapy.xOcean", "qualname": "OceanSet.psal", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.SR", "modulename": "lenapy.xOcean", "qualname": "OceanSet.SR", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.SA", "modulename": "lenapy.xOcean", "qualname": "OceanSet.SA", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.P", "modulename": "lenapy.xOcean", "qualname": "OceanSet.P", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.rho", "modulename": "lenapy.xOcean", "qualname": "OceanSet.rho", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.sigma0", "modulename": "lenapy.xOcean", "qualname": "OceanSet.sigma0", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.Cp", "modulename": "lenapy.xOcean", "qualname": "OceanSet.Cp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.heat", "modulename": "lenapy.xOcean", "qualname": "OceanSet.heat", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.slh", "modulename": "lenapy.xOcean", "qualname": "OceanSet.slh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.ohc", "modulename": "lenapy.xOcean", "qualname": "OceanSet.ohc", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.ssl", "modulename": "lenapy.xOcean", "qualname": "OceanSet.ssl", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.ieeh", "modulename": "lenapy.xOcean", "qualname": "OceanSet.ieeh", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.gohc", "modulename": "lenapy.xOcean", "qualname": "OceanSet.gohc", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.gohc_TOA", "modulename": "lenapy.xOcean", "qualname": "OceanSet.gohc_TOA", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.ohc_above", "modulename": "lenapy.xOcean", "qualname": "OceanSet.ohc_above", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xOcean.OceanSet.gohc_above", "modulename": "lenapy.xOcean", "qualname": "OceanSet.gohc_above", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"n\">na_eq_zero</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xOcean.OceanSet.ocean_depth", "modulename": "lenapy.xOcean", "qualname": "OceanSet.ocean_depth", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.mld_theta0", "modulename": "lenapy.xOcean", "qualname": "OceanSet.mld_theta0", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.mld_theta0minus_only", "modulename": "lenapy.xOcean", "qualname": "OceanSet.mld_theta0minus_only", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.mld_sigma0", "modulename": "lenapy.xOcean", "qualname": "OceanSet.mld_sigma0", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanSet.mld_sigma0var", "modulename": "lenapy.xOcean", "qualname": "OceanSet.mld_sigma0var", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "lenapy.xOcean.OceanArray", "modulename": "lenapy.xOcean", "qualname": "OceanArray", "kind": "class", "doc": "<p>This class extends any dataarray to a xOcean object, to perform specific operations on structured dataarray</p>\n", "bases": "lenapy.xGeo.GeoArray"}, {"fullname": "lenapy.xOcean.OceanArray.__init__", "modulename": "lenapy.xOcean", "qualname": "OceanArray.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xarray_obj</span></span>)</span>"}, {"fullname": "lenapy.xOcean.OceanArray.add_value_surface", "modulename": "lenapy.xOcean", "qualname": "OceanArray.add_value_surface", "kind": "function", "doc": "<p>Add a surface layer with a specified value, or the previous upper value</p>\n\n<h2 id=\"parameter\">Parameter</h2>\n\n<p>value : float or array-like, optional\n    values to be added in the surface layer (depth=0). If None, the previous upper value is used to fill the new layer</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>added : DataArray\n    new dataarray with a extra layer at depth 0 filled with required values</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data=IAP('/home/usr/lenapy/data/IAP')\n      heat=data.xocean.heat.xocean.add_value_surface()</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xOcean.OceanArray.integ_depth", "modulename": "lenapy.xOcean", "qualname": "OceanArray.integ_depth", "kind": "function", "doc": "<p>Returns the dataarray integrated over the whole depth. The surface value is supposed equal to the most shallow value.\nIn order to deal with NaN values in deep water during integration,, all NaN are firt converted to 0, then in the output \narray NaN values are applied where initial surface values were NaN.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data=IAP('/home/usr/lenapy/data/IAP')\n      data.xocean.heat.xocean.integ_depth() <br />\n      <xarray.DataArray 'Heat' (time: 156, latitude: 180, longitude: 360)&gt;\n      dask.array<where, shape=(156, 180, 360), dtype=float64, chunksize=(1, 180, 360), chunktype=numpy.ndarray>\n      Coordinates:</p>\n      \n      <ul>\n      <li>latitude   (latitude) float32 -89.5 -88.5 -87.5 -86.5 ... 87.5 88.5 89.5</li>\n      <li>longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 357.0 358.0 359.0 360.0</li>\n      <li>time       (time) datetime64[ns] 2005-01-15 2005-02-15 ... 2017-12-15\n      depth      float32 1.0</li>\n      </ul>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xOcean.OceanArray.cum_integ_depth", "modulename": "lenapy.xOcean", "qualname": "OceanArray.cum_integ_depth", "kind": "function", "doc": "<p>Returns a cumulative integrated dataarray integrated over the whole depth. The surface value is supposed equal to the \nmost shallow value. A first integration layer by layer is performed, by multupliying the layer's thickness by the mean\nvalue of upper and lower bound, then a cumulative sum is computed.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data=IAP('/home/usr/lenapy/data/IAP')\n      data.xocean.heat.xocean.cum_integ_depth() <br />\n      <xarray.DataArray (time: 156, latitude: 180, longitude: 360, depth: 41)&gt;\n      dask.array<where, shape=(156, 180, 360, 41), dtype=float64, chunksize=(1, 180, 360, 10), chunktype=numpy.ndarray>\n      Coordinates:</p>\n      \n      <ul>\n      <li>latitude   (latitude) float32 -89.5 -88.5 -87.5 -86.5 ... 87.5 88.5 89.5</li>\n      <li>longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 357.0 358.0 359.0 360.0</li>\n      <li>time       (time) datetime64[ns] 2005-01-15 2005-02-15 ... 2017-12-15</li>\n      <li>depth      (depth) float64 1.0 5.0 10.0 20.0 ... 1.7e+03 1.8e+03 2e+03</li>\n      </ul>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "lenapy.xOcean.OceanArray.above", "modulename": "lenapy.xOcean", "qualname": "OceanArray.above", "kind": "function", "doc": "<p>Returns the dataarray integrated above a given depth, by interpolating at this depth the cumulative integrale \nof the data array</p>\n\n<h2 id=\"example\">Example</h2>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>data=IAP('/home/usr/lenapy/data/IAP')\n      mld=data.xocean.mld_sigma0\n      data.xocean.heat.xocean.above(mld) <br />\n      <xarray.DataArray (time: 156, latitude: 180, longitude: 360)&gt;\n      dask.array<where, shape=(156, 180, 360), dtype=float64, chunksize=(1, 180, 360), chunktype=numpy.ndarray>\n      Coordinates:\n          depth      (time, latitude, longitude) float64 dask.array<chunksize=(1, 180, 360), meta=np.ndarray></p>\n      \n      <ul>\n      <li>time       (time) datetime64[ns] 2005-01-15 2005-02-15 ... 2017-12-15</li>\n      <li>latitude   (latitude) float32 -89.5 -88.5 -87.5 -86.5 ... 87.5 88.5 89.5</li>\n      <li>longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 357.0 358.0 359.0 360.0</li>\n      </ul>\n    </blockquote>\n  </blockquote>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">depth</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();