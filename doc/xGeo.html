<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lenapy.xGeo API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lenapy.xGeo</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

import numpy as np
import xarray as xr
import xesmf as xe
import os.path
from .utils import *
from .plotting import *
from .sandbox import *
from .produits import rename_data

def open_geodata(file,*args,rename={},nan=None,chunks=None,**kwargs):
    &#34;&#34;&#34;
    Open a dataset base on xr.open_dataset method, while normalizing coordinates names and choosing NaN values
    
    Parameters
    ----------
    file : path
        pathname of the file to open
    *args : optional
        any arguments passed to open_dataset method
    rename : dict, optional
        dictionnary {old_name:new_name,...}
    nan : optional
        value to be replaced by NaN
    chunks : dict, optional
        dictionnaty to perform chunks on data
    **kwargs : optional
        any keyword arguments passed to open_dataset method
        
    Returns
    -------
    data : Dataset
        Dataset loaded from file
    
    Example
    -------
    data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;)
    &#34;&#34;&#34;
    res=rename_data(xr.open_dataset(file,*args,**kwargs),**rename)
    return res.where(res!=nan).chunk(chunks=chunks)

def open_mfgeodata(fic,*args,rename={},nan=None,chunks=None,**kwargs):
    &#34;&#34;&#34;
    Open a dataset base on xr.open_mfdataset method, while normalizing coordinates names and choosing NaN values
    
    Parameters
    ----------
    file : path
        pattern fitting the file to open
    *args : optional
        any arguments passed to open_dataset method
    rename : dict, optional
        dictionnary {old_name:new_name,...}
    nan : optional
        value to be replaced by NaN
    chunks : dict, optional
        dictionnaty to perform chunks on data
    **kwargs : optional
        any keyword arguments passed to open_dataset method
        
    Returns
    -------
    data : Dataset
        Dataset loaded from file
    
    Example
    -------
    data = xgeo.open_mfgeodata(&#39;/home/user/lenapy/data/gohc_*.nc&#39;)
    &#34;&#34;&#34;
    res=rename_data(xr.open_mfdataset(fic,*args,**kwargs),**rename)
    return res.where(res!=nan).chunk(chunks=chunks)
    
@xr.register_dataset_accessor(&#34;xgeo&#34;)
class GeoSet:
    &#34;&#34;&#34;
    This class implements an extension of any dataset to add some usefull methods often used in earth science data handling
    &#34;&#34;&#34;
    def __init__(self, xarray_obj):
        self._obj = xarray_obj
        
    def climato(self,**kwargs):
        &#34;&#34;&#34;
        Perform climato analysis on all the variables in a dataset
        Input data are decomposed into :
            annual cycle
            semi-annual cycle
            trend
            mean
            residual signal
        The returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)
        If return_coeffs=True, the coefficients of the decompositions are returned
        
        Parameters
        ----------
        signal : Bool (default=True)
            returns residual signal
        mean : Bool (default=True)
            returns mean signal
        trend : Bool (default=True)
            returns trend
        cycle : Bool (default=False)
            return annual and semi-annual cycles
        return_coeffs : Bool (default=False)
            returns cycle coefficient, mean and trend
            retourne en plus les coefficients des cycles et de la tendance linéaire
            
        Returns
        -------
        climato : dataset
            a dataset with the same structure as the input, with modified data according to the chosen options
        if return_coeffs=True, an extra dataset is provided with the coefficients of the decomposition
        
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;)
        &gt;&gt;&gt;output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)
        &#34;&#34;&#34;

        # Pour toutes les données dépendant du temps, retourne l&#39;analyse de la climato
        res={}
        for var in self._obj.data_vars:
            if &#39;time&#39; in self._obj[var].coords:
                res[var]=climato(self._obj[var],**kwargs)
            else:
                res[var]=self._obj[var]
        return xr.Dataset(res)

    def mean(self,*args,**kwargs):
        &#34;&#34;&#34;
        Returns the averaged value of all variables in dataset along specified dimension, applying specified weights
        
        Parameters
        ----------
        *args : list
            list of the dimensions along which to average
        
        weights : None or list or dataarray
            if None, no weight is applyed
            if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                    the thickness of the layer
            if dataarray :
                    input data are multiplied by this dataarray before averaging
        mask : None or dataarray
            mask to be applyed befire averaging
        na_eq_zero : boolean (default=False)
            replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones
        **kwargs : keyword arguments
            any keyword arguments passe to the native xarray.mean function
            
        Returns
        -------
        averaged : dataset
            dataset with all variables averaged according to specified options
            
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;)
        &gt;&gt;&gt;avg = data.xgeo.mean([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;],na_eq_zero=True)
            
        &#34;&#34;&#34;
        res={}
        for var in self._obj.data_vars:
            res[var]=self._obj[var].xgeo.mean(*args,**kwargs)
        return xr.Dataset(res)

    def sum(self,*args,**kwargs):
        &#34;&#34;&#34;
        Returns the sum for all variables in dataset along specified dimension, applying specified weights
        
        Parameters
        ----------
        *args : list
            list of the dimensions along which to sum
        
        weights : None or list or dataarray
            if None, no weight is applyed
            if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                    the thickness of the layer
            if dataarray :
                    input data are multiplied by this dataarray before summing
        mask : None or dataarray
            mask to be applyed before summing
        **kwargs : keyword arguments
            any keyword arguments passe to the native xarray.sum function
            
        Returns
        -------
        averaged : dataset
            dataset with all variablessummed according to specified options
            
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;)
        &gt;&gt;&gt;avg = data.xgeo.sum([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;])
            
        &#34;&#34;&#34;             
        res={}
        for var in self._obj.data_vars:
            res[var]=self._obj[var].xgeo.sum(*args,**kwargs)
        return xr.Dataset(res)
    
    
    def isosurface(self, dim, criterion, upper=False):
        &#34;&#34;&#34;
        Compute the isosurface along the specified coordinate at the value defined  by the kwarg field=value.
        For example, we want to compute the isosurface defined by a temperature of 10°C along depth dimension.
        All data variables of the data set are interpolated on this iso surface
        Data is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,
        starting from the end (bottom) if upper=False, or from the beggining (top) if upper=True
        
        Parameters
        ----------
        dim : string
            dimension along which to compute the isosurface
        criterion : dict
            one-entry dictionnary with the key equal to a variable of the dataset, and the value equal to the isosurface criterion
        upper : boolean (default=False)
            order to perform the research of the criterion value. If False, from the end, if True, form the beggining
            
        Returns
        -------
        isosurface : dataset
            Dataset with all the variables interpolated at the criterion value along chosen dimension. The variables chosen for
                criterion should contain a constant value equal to the criterion. the dimension chosen for the isosurface computation
                is filled with the isosurface itself.
                
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;)
        &gt;&gt;&gt;data.isosurface(&#39;depth&#39;,dict(temp=3))
        &lt;xarray.Dataset&gt;
        Dimensions:    (latitude: 90, longitude: 180)
        Coordinates:
          * latitude   (latitude) float32 -44.5 -43.5 -42.5 -41.5 ... 42.5 43.5 44.5
          * longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 177.0 178.0 179.0 180.0
            time       datetime64[ns] 2005-01-15
            depth      (latitude, longitude) float64 918.6 745.8 704.8 ... 912.2 920.0
        Data variables:
            depth_iso  (latitude, longitude) float64 918.6 745.8 704.8 ... 912.2 920.0
            temp       (latitude, longitude) float64 3.0 3.0 3.0 3.0 ... 3.0 3.0 3.0 3.0
            SA         (latitude, longitude) float64 34.48 34.39 34.39 ... 34.53 34.52

        
        &#34;&#34;&#34;
        # Calcule l&#39;isosurface selon la coordonnée &#39;dim&#39; pour le champ défini par le dictionnaire **kwargs (ex : temp=10)
        # Retourne tous les champs interpolés sur cette isosurface (pour ceux ayant &#34;dim&#34; en coordonnée), ainsi que l&#39;isosurface elle-même
        k=list(criterion.keys())[0]
        if not(k in self._obj.data_vars):
            raise KeyError(&#34;%s not in %s&#34;%(criterion[0],list(data_vars)))
            
        r=isosurface(self._obj[k],criterion[k],dim, upper=upper)
        res=xr.Dataset()
        for var in self._obj.data_vars:
            if dim in self._obj[var].coords:
                res[var]=self._obj[var].interp({dim:r})
            else:
                res[var]=self._obj[var]

        return res

    def regridder(self,gr_out,*args,mask_in=None,**kwargs):
        &#34;&#34;&#34;
        Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataset 
        coordinates to gr_out coordinates

        Parameters
        ----------
        gr_out : dataset
            dataset containing the coordinates to regrid on
        *args : 
            any argument passed to xesmf.Regridder method
        mask_in : None or dataarray
            mask to be applied on the data to regrid
        *kwargs : 
            any keyword argument passed to xesmf.Regridder method

        Returns
        -------
        regridder : xesmf.Regridder instance
            regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates
        &#34;&#34;&#34;
        if not &#39;latitude&#39; in gr_out.coords: raise AssertionError(&#39;The latitude coordinates does not exist&#39;)
        if not &#39;longitude&#39; in gr_out.coords: raise AssertionError(&#39;The longitude coordinates does not exist&#39;)

        ds=self._obj
        if type(mask_in)==xr.DataArray:
            ds[&#39;mask&#39;]=mask_in
            
        ds_out=xr.Dataset({
        &#34;latitude&#34;:gr_out.latitude,
        &#34;longitude&#34;:gr_out.longitude
        })

        return xe.Regridder(ds,ds_out,*args,**kwargs)
    
    def regrid(self,regridder,*args,**kwargs):
        &#34;&#34;&#34;
        Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates

        Parameters
        ----------
        regridder : xesmf.Regridder instance
            regridder set with the xgeo.regridder method

        *args : 
            any argument passed to xesmf regridder method
        *kwargs : 
            any keyword argument passed to xesmf regridder method

        Returns
        -------
        regrid : dataset
            dataset regridded to gr_out coordinates

        Example
        -------
        &gt;&gt;&gt;ds_out = xr.Dataset({&#34;latitude&#34;:([&#34;latitude&#34;],np.arange(-89.5,90,1.)),
        &gt;&gt;&gt;                     &#34;longitude&#34;:([&#34;longitude&#34;],np.arange(-179.5,180,1.))})
        &gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&#34;conservative_normed&#34;,periodic=True)
        &gt;&gt;&gt;out = data.xgeo.regrid(regridder)
        &#34;&#34;&#34;
        return regridder(self._obj,*args,**kwargs)
    
    def filter(self, filter_name=lanczos,q=3, **kwargs):
        &#34;&#34;&#34;
        Apply a specified filter on all the time-dependent data in the dataset
        Boundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data
        Available filters are in the .utils python file
        
        Parameters
        ----------
        filter_name : function
            filter function name, from the .utils file
        q : int
            order of the polyfit to handle boundary effects
        **kwargs :
            keyword arguments for the chosen filter
            
        Returns
        -------
        filtered : filtered dataset
        
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;)
        &gt;&gt;&gt;data.xgeo.filter(lanczos,q=3,coupure=12,order=2)
        
        &#34;&#34;&#34;
        res={}
        for var in self._obj.data_vars:
            if &#39;time&#39; in self._obj[var].coords:
                res[var]=self._obj[var].xgeo.filter(filter_name=filter_name,q=q,**kwargs)
            else:
                res[var]=self._obj[var]
        return xr.Dataset(res)

    def interp_time(self,other,**kwargs):
        &#34;&#34;&#34;
        Interpolate dataarray at the same dates than other
        
        Parameter
        ---------
        other : dataarray
            must have a time dimension
            
        Return
        ------
        interpolated : dataarray
            new dataarray interpolated
        &#34;&#34;&#34;        
        res={}
        for var in self._obj.data_vars:
            if &#39;time&#39; in self._obj[var].coords:
                res[var]=self._obj[var].xgeo.interp_time(other,**kwargs)
            else:
                res[var]=self._obj[var]
        return xr.Dataset(res)

    def to_datetime(self,input_type):
        &#34;&#34;&#34;
        Convert dataset time format to standard pandas time format
        
        Parameter
        ---------
        input_type : string
            Can be &#39;frac_year&#39; or &#39;360_day&#39;
            
        Return
        ------
        converted : dataset
            new dataset with the time dimension in a standard pandas format
        &#34;&#34;&#34;
        return to_datetime(self._obj,input_type)        

    def fill_time(self):
        &#34;&#34;&#34;
        Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN
        but real absent points in the timeseries. A linear interpolation is performed at the missing points.
        &#34;&#34;&#34;
        return fill_time(self._obj)
        
@xr.register_dataarray_accessor(&#34;xgeo&#34;)
class GeoArray:
    def __init__(self, xarray_obj):
        self._obj = xarray_obj
        
    def climato(self,**kwargs):
        &#34;&#34;&#34;
        Perform climato analysis on a dataarray
        Input data are decomposed into :
            annual cycle
            semi-annual cycle
            trend
            mean
            residual signal
        The returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)
        If return_coeffs=True, the coefficients of the decompositions are returned
        
        Parameters
        ----------
        signal : Bool (default=True)
            returns residual signal
        mean : Bool (default=True)
            returns mean signal
        trend : Bool (default=True)
            returns trend
        cycle : Bool (default=False)
            return annual and semi-annual cycles
        return_coeffs : Bool (default=False)
            returns cycle coefficient, mean and trend
            retourne en plus les coefficients des cycles et de la tendance linéaire
            
        Returns
        -------
        climato : dataarray
            a dataarray with the same structure as the input, with modified data according to the chosen options
        if return_coeffs=True, an extra dataset is provided with the coefficients of the decomposition
        
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;).ohc
        &gt;&gt;&gt;output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)
        &#34;&#34;&#34;
        return climato(self._obj,**kwargs)
        
    def mean(self,*args,weights=None,mask=True,na_eq_zero=False,**kwargs):
        &#34;&#34;&#34;
        Returns the averaged value of dataarray along specified dimension, applying specified weights
        
        Parameters
        ----------
        *args : list
            list of the dimensions along which to average
        
        weights : None or list or dataarray
            if None, no weight is applyed
            if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                    the thickness of the layer
            if dataarray :
                    input data are multiplied by this dataarray before averaging
        mask : None or dataarray
            mask to be applyed before averaging
        na_eq_zero : boolean (default=False)
            replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones
        **kwargs : keyword arguments
            any keyword arguments passe to the native xarray.mean function
            
        Returns
        -------
        averaged : dataarray
            dataarray averaged according to specified options
            
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).temp
        &gt;&gt;&gt;avg = data.xgeo.mean([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;],na_eq_zero=True)
            
        &#34;&#34;&#34;
        argmean=set(np.ravel(*args)).intersection(list(self._obj.coords))
        data=self._obj.where(mask)
        if na_eq_zero:
            data=data.fillna(0.)
            
        if len(argmean)==0:
            argmean=None
        if type(weights)==type(None):
            # Moyenne simple
            return data.mean(argmean,**kwargs)
        elif type(weights)==list or type(weights)==str:
            w=1
            if &#39;latitude&#39; in weights and &#39;latitude&#39; in self._obj.coords:
                # poids = cos(latitude)
                w=np.cos(np.radians(self._obj.latitude))
            if &#39;depth&#39; in weights and &#39;depth&#39; in self._obj.coords:
                # poids *= épaisseur des couches (l&#39;épaisseur de la première couche est la première profondeur)
                w=w*xr.concat((self._obj.depth.isel(depth=0),self._obj.depth.diff(dim=&#39;depth&#39;)),dim=&#39;depth&#39;)
            return data.weighted(w).mean(argmean,**kwargs)
        else:
            # matrice de poids définie par l&#39;utilisateur
            return data.weighted(weights).mean(argmean,**kwargs)
    
    def sum(self,*args,weights=None,mask=True,**kwargs):
        &#34;&#34;&#34;
        Returns the sum of dataarray along specified dimension, applying specified weights
        
        Parameters
        ----------
        *args : list
            list of the dimensions along which to sum
        
        weights : None or list or dataarray
            if None, no weight is applyed
            if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                    the thickness of the layer
            if dataarray :
                    input data are multiplied by this dataarray before summing
        mask : None or dataarray
            mask to be applyed before summing
        **kwargs : keyword arguments
            any keyword arguments passe to the native xarray.sum function
            
        Returns
        -------
        averaged : dataarray
            dataarray summed according to specified options
            
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).heat
        &gt;&gt;&gt;avg = data.xgeo.sum([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;])
            
        &#34;&#34;&#34;       
        argsum=set(np.ravel(*args)).intersection(list(self._obj.coords))
        data=self._obj.where(mask)        
        if type(weights)==type(None):
            # Somme simple
            return data.sum(argsum,**kwargs)
        elif type(weights)==list or type(weights)==str:
            w=1
            if &#39;latitude&#39; in weights and &#39;latitude&#39; in self._obj.coords:
                # poids = cos(latitude)
                w=np.cos(np.radians(self._obj.latitude))
            if &#39;depth&#39; in weights and &#39;depth&#39; in self._obj.coords:
                # poids *= épaisseur des couches (l&#39;épaisseur de la première couche est la première profondeur)
                w=w*xr.concat((self._obj.depth.isel(depth=0),self._obj.depth.diff(dim=&#39;depth&#39;)),dim=&#39;depth&#39;)
            return data.weighted(w).sum(argsum,**kwargs)
        else:
            # matrice de poids définie par l&#39;utilisateur
            return data.weighted(weights).sum(argsum,**kwargs)
    

    def isosurface(self, target, dim, upper=False):   
        &#34;&#34;&#34;
        Compute the isosurface along the specified coordinate at the value defined  by the target.
        Data is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,
        starting from the end (bottom) if upper=False, or from the beggining (top) if upper=True
        
        Parameters
        ----------
        target : float
            criterion value to be satisfied at the iso surface
        dim : string
            dimension along which to compute the isosurface
        upper : boolean (default=False)
            order to perform the research of the criterion value. If False, from the end, if True, form the beggining
            
        Returns
        -------
        isosurface : dataarray
            Dataarray containing the isosurface along the dimension dim on which data=target.
                
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).temp
        &gt;&gt;&gt;data.isosurface(3,&#39;depth&#39;)
        &lt;xarray.DataArray (latitude: 90, longitude: 180)&gt;
        dask.array&lt;_nanmax_skip-aggregate, shape=(90, 180), dtype=float64, chunksize=(90, 180), chunktype=numpy.ndarray&gt;
        Coordinates:
          * latitude   (latitude) float32 -44.5 -43.5 -42.5 -41.5 ... 42.5 43.5 44.5
          * longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 177.0 178.0 179.0 180.0
            time       datetime64[ns] 2005-01-15
        &#34;&#34;&#34;        
        return isosurface(self._obj,target,dim,upper=upper)

    def regridder(self,gr_out,*args,mask_in=None,**kwargs):
        &#34;&#34;&#34;
        Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataarray 
        coordinates to gr_out coordinates

        Parameters
        ----------
        gr_out : dataset
            dataset containing the coordinates to regrid on
        *args : 
            any argument passed to xesmf.Regridder method
        mask_in : None or dataarray
            mask to be applied on the data to regrid
        *kwargs : 
            any keyword argument passed to xesmf.Regridder method

        Returns
        -------
        regridder : xesmf.Regridder instance
            regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates
        &#34;&#34;&#34;

        ds=xr.Dataset({&#39;data&#39;:self._obj})
        return ds.xgeo.regridder(gr_out,*args,mask_in,**kwargs)
    
    def regrid(self,regridder,*args,**kwargs):
        &#34;&#34;&#34;
        Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates

        Parameters
        ----------
        regridder : xesmf.Regridder instance
            regridder set with the xgeo.regridder method

        *args : 
            any argument passed to xesmf regridder method
        *kwargs : 
            any keyword argument passed to xesmf regridder method

        Returns
        -------
        regrid : dataset
            dataset regridded to gr_out coordinates

        Example
        -------
        &gt;&gt;&gt;ds_out = xr.Dataset({&#34;latitude&#34;:([&#34;latitude&#34;],np.arange(-89.5,90,1.)),
        &gt;&gt;&gt;                     &#34;longitude&#34;:([&#34;longitude&#34;],np.arange(-179.5,180,1.))})
        &gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&#34;conservative_normed&#34;,periodic=True)
        &gt;&gt;&gt;out = data.xgeo.regrid(regridder)
        &#34;&#34;&#34;        
        return regridder(self._obj,*args,**kwargs)

    def filter(self, filter_name=lanczos,q=3, **kwargs):
        &#34;&#34;&#34;
        Apply a specified filter on all the time-dependent datarray
        Boundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data
        Available filters are in the .utils python file
        
        Parameters
        ----------
        filter_name : function
            filter function name, from the .utils file
        q : int
            order of the polyfit to handle boundary effects
        **kwargs :
            keyword arguments for the chosen filter
            
        Returns
        -------
        filtered : filtered dataset
        
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).temp
        &gt;&gt;&gt;data.xgeo.filter(lanczos,q=3,coupure=12,order=2)
        
        &#34;&#34;&#34;        
        return filter(self._obj,filter_name=filter_name,q=q,**kwargs)
    
    def interp_time(self,other,**kwargs):
        &#34;&#34;&#34;
        Interpolate dataarray at the same dates than other
        
        Parameter
        ---------
        other : dataarray
            must have a time dimension
            
        Return
        ------
        interpolated : dataarray
            new dataarray interpolated
        &#34;&#34;&#34;        
        return interp_time(self._obj,other,**kwargs)
    
    def plot_timeseries_uncertainty(self, **kwargs):
        plot_timeseries_uncertainty(self._obj, **kwargs)
        
    def to_datetime(self,input_type):
        &#34;&#34;&#34;
        Convert dataarray time format to standard pandas time format
        
        Parameter
        ---------
        input_type : string
            Can be &#39;frac_year&#39; or &#39;360_day&#39;
            
        Return
        ------
        converted : dataarray
            new dataarray with the time dimension in a standard pandas format
        &#34;&#34;&#34;
        return to_datetime(self._obj,input_type)        

    def diff_3pts(self,dim):
        &#34;&#34;&#34;
        Derivative formula along the selected dimension, returning on each point the linear regression on the three points
        defined by the selected point and its two neighbours
        &#34;&#34;&#34;
        return diff_3pts(self._obj,dim)

    def to_difgri(self,dir_out,prefix,suffix):
        to_difgri(self._obj,dir_out,prefix,suffix)

    def trend(self):
        &#34;&#34;&#34;
        Perform a linear regression on the data, and returns the slope coefficient
        &#34;&#34;&#34;
        return trend(self._obj)
    
    def fill_time(self):
        &#34;&#34;&#34;
        Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN
        but real absent points in the timeseries. A linear interpolation is performed at the missing points.
        &#34;&#34;&#34;
        return fill_time(self._obj)
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lenapy.xGeo.open_geodata"><code class="name flex">
<span>def <span class="ident">open_geodata</span></span>(<span>file, *args, rename={}, nan=None, chunks=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Open a dataset base on xr.open_dataset method, while normalizing coordinates names and choosing NaN values</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>path</code></dt>
<dd>pathname of the file to open</dd>
<dt><strong><code>*args</code></strong> :&ensp;<code>optional</code></dt>
<dd>any arguments passed to open_dataset method</dd>
<dt><strong><code>rename</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>dictionnary {old_name:new_name,&hellip;}</dd>
<dt><strong><code>nan</code></strong> :&ensp;<code>optional</code></dt>
<dd>value to be replaced by NaN</dd>
<dt><strong><code>chunks</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>dictionnaty to perform chunks on data</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>optional</code></dt>
<dd>any keyword arguments passed to open_dataset method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dataset</code></dt>
<dd>Dataset loaded from file</dd>
</dl>
<h2 id="example">Example</h2>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_geodata(file,*args,rename={},nan=None,chunks=None,**kwargs):
    &#34;&#34;&#34;
    Open a dataset base on xr.open_dataset method, while normalizing coordinates names and choosing NaN values
    
    Parameters
    ----------
    file : path
        pathname of the file to open
    *args : optional
        any arguments passed to open_dataset method
    rename : dict, optional
        dictionnary {old_name:new_name,...}
    nan : optional
        value to be replaced by NaN
    chunks : dict, optional
        dictionnaty to perform chunks on data
    **kwargs : optional
        any keyword arguments passed to open_dataset method
        
    Returns
    -------
    data : Dataset
        Dataset loaded from file
    
    Example
    -------
    data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;)
    &#34;&#34;&#34;
    res=rename_data(xr.open_dataset(file,*args,**kwargs),**rename)
    return res.where(res!=nan).chunk(chunks=chunks)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.open_mfgeodata"><code class="name flex">
<span>def <span class="ident">open_mfgeodata</span></span>(<span>fic, *args, rename={}, nan=None, chunks=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Open a dataset base on xr.open_mfdataset method, while normalizing coordinates names and choosing NaN values</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>path</code></dt>
<dd>pattern fitting the file to open</dd>
<dt><strong><code>*args</code></strong> :&ensp;<code>optional</code></dt>
<dd>any arguments passed to open_dataset method</dd>
<dt><strong><code>rename</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>dictionnary {old_name:new_name,&hellip;}</dd>
<dt><strong><code>nan</code></strong> :&ensp;<code>optional</code></dt>
<dd>value to be replaced by NaN</dd>
<dt><strong><code>chunks</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>dictionnaty to perform chunks on data</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>optional</code></dt>
<dd>any keyword arguments passed to open_dataset method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dataset</code></dt>
<dd>Dataset loaded from file</dd>
</dl>
<h2 id="example">Example</h2>
<p>data = xgeo.open_mfgeodata('/home/user/lenapy/data/gohc_*.nc')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_mfgeodata(fic,*args,rename={},nan=None,chunks=None,**kwargs):
    &#34;&#34;&#34;
    Open a dataset base on xr.open_mfdataset method, while normalizing coordinates names and choosing NaN values
    
    Parameters
    ----------
    file : path
        pattern fitting the file to open
    *args : optional
        any arguments passed to open_dataset method
    rename : dict, optional
        dictionnary {old_name:new_name,...}
    nan : optional
        value to be replaced by NaN
    chunks : dict, optional
        dictionnaty to perform chunks on data
    **kwargs : optional
        any keyword arguments passed to open_dataset method
        
    Returns
    -------
    data : Dataset
        Dataset loaded from file
    
    Example
    -------
    data = xgeo.open_mfgeodata(&#39;/home/user/lenapy/data/gohc_*.nc&#39;)
    &#34;&#34;&#34;
    res=rename_data(xr.open_mfdataset(fic,*args,**kwargs),**rename)
    return res.where(res!=nan).chunk(chunks=chunks)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lenapy.xGeo.GeoArray"><code class="flex name class">
<span>class <span class="ident">GeoArray</span></span>
<span>(</span><span>xarray_obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@xr.register_dataarray_accessor(&#34;xgeo&#34;)
class GeoArray:
    def __init__(self, xarray_obj):
        self._obj = xarray_obj
        
    def climato(self,**kwargs):
        &#34;&#34;&#34;
        Perform climato analysis on a dataarray
        Input data are decomposed into :
            annual cycle
            semi-annual cycle
            trend
            mean
            residual signal
        The returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)
        If return_coeffs=True, the coefficients of the decompositions are returned
        
        Parameters
        ----------
        signal : Bool (default=True)
            returns residual signal
        mean : Bool (default=True)
            returns mean signal
        trend : Bool (default=True)
            returns trend
        cycle : Bool (default=False)
            return annual and semi-annual cycles
        return_coeffs : Bool (default=False)
            returns cycle coefficient, mean and trend
            retourne en plus les coefficients des cycles et de la tendance linéaire
            
        Returns
        -------
        climato : dataarray
            a dataarray with the same structure as the input, with modified data according to the chosen options
        if return_coeffs=True, an extra dataset is provided with the coefficients of the decomposition
        
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;).ohc
        &gt;&gt;&gt;output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)
        &#34;&#34;&#34;
        return climato(self._obj,**kwargs)
        
    def mean(self,*args,weights=None,mask=True,na_eq_zero=False,**kwargs):
        &#34;&#34;&#34;
        Returns the averaged value of dataarray along specified dimension, applying specified weights
        
        Parameters
        ----------
        *args : list
            list of the dimensions along which to average
        
        weights : None or list or dataarray
            if None, no weight is applyed
            if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                    the thickness of the layer
            if dataarray :
                    input data are multiplied by this dataarray before averaging
        mask : None or dataarray
            mask to be applyed before averaging
        na_eq_zero : boolean (default=False)
            replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones
        **kwargs : keyword arguments
            any keyword arguments passe to the native xarray.mean function
            
        Returns
        -------
        averaged : dataarray
            dataarray averaged according to specified options
            
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).temp
        &gt;&gt;&gt;avg = data.xgeo.mean([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;],na_eq_zero=True)
            
        &#34;&#34;&#34;
        argmean=set(np.ravel(*args)).intersection(list(self._obj.coords))
        data=self._obj.where(mask)
        if na_eq_zero:
            data=data.fillna(0.)
            
        if len(argmean)==0:
            argmean=None
        if type(weights)==type(None):
            # Moyenne simple
            return data.mean(argmean,**kwargs)
        elif type(weights)==list or type(weights)==str:
            w=1
            if &#39;latitude&#39; in weights and &#39;latitude&#39; in self._obj.coords:
                # poids = cos(latitude)
                w=np.cos(np.radians(self._obj.latitude))
            if &#39;depth&#39; in weights and &#39;depth&#39; in self._obj.coords:
                # poids *= épaisseur des couches (l&#39;épaisseur de la première couche est la première profondeur)
                w=w*xr.concat((self._obj.depth.isel(depth=0),self._obj.depth.diff(dim=&#39;depth&#39;)),dim=&#39;depth&#39;)
            return data.weighted(w).mean(argmean,**kwargs)
        else:
            # matrice de poids définie par l&#39;utilisateur
            return data.weighted(weights).mean(argmean,**kwargs)
    
    def sum(self,*args,weights=None,mask=True,**kwargs):
        &#34;&#34;&#34;
        Returns the sum of dataarray along specified dimension, applying specified weights
        
        Parameters
        ----------
        *args : list
            list of the dimensions along which to sum
        
        weights : None or list or dataarray
            if None, no weight is applyed
            if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                    the thickness of the layer
            if dataarray :
                    input data are multiplied by this dataarray before summing
        mask : None or dataarray
            mask to be applyed before summing
        **kwargs : keyword arguments
            any keyword arguments passe to the native xarray.sum function
            
        Returns
        -------
        averaged : dataarray
            dataarray summed according to specified options
            
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).heat
        &gt;&gt;&gt;avg = data.xgeo.sum([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;])
            
        &#34;&#34;&#34;       
        argsum=set(np.ravel(*args)).intersection(list(self._obj.coords))
        data=self._obj.where(mask)        
        if type(weights)==type(None):
            # Somme simple
            return data.sum(argsum,**kwargs)
        elif type(weights)==list or type(weights)==str:
            w=1
            if &#39;latitude&#39; in weights and &#39;latitude&#39; in self._obj.coords:
                # poids = cos(latitude)
                w=np.cos(np.radians(self._obj.latitude))
            if &#39;depth&#39; in weights and &#39;depth&#39; in self._obj.coords:
                # poids *= épaisseur des couches (l&#39;épaisseur de la première couche est la première profondeur)
                w=w*xr.concat((self._obj.depth.isel(depth=0),self._obj.depth.diff(dim=&#39;depth&#39;)),dim=&#39;depth&#39;)
            return data.weighted(w).sum(argsum,**kwargs)
        else:
            # matrice de poids définie par l&#39;utilisateur
            return data.weighted(weights).sum(argsum,**kwargs)
    

    def isosurface(self, target, dim, upper=False):   
        &#34;&#34;&#34;
        Compute the isosurface along the specified coordinate at the value defined  by the target.
        Data is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,
        starting from the end (bottom) if upper=False, or from the beggining (top) if upper=True
        
        Parameters
        ----------
        target : float
            criterion value to be satisfied at the iso surface
        dim : string
            dimension along which to compute the isosurface
        upper : boolean (default=False)
            order to perform the research of the criterion value. If False, from the end, if True, form the beggining
            
        Returns
        -------
        isosurface : dataarray
            Dataarray containing the isosurface along the dimension dim on which data=target.
                
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).temp
        &gt;&gt;&gt;data.isosurface(3,&#39;depth&#39;)
        &lt;xarray.DataArray (latitude: 90, longitude: 180)&gt;
        dask.array&lt;_nanmax_skip-aggregate, shape=(90, 180), dtype=float64, chunksize=(90, 180), chunktype=numpy.ndarray&gt;
        Coordinates:
          * latitude   (latitude) float32 -44.5 -43.5 -42.5 -41.5 ... 42.5 43.5 44.5
          * longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 177.0 178.0 179.0 180.0
            time       datetime64[ns] 2005-01-15
        &#34;&#34;&#34;        
        return isosurface(self._obj,target,dim,upper=upper)

    def regridder(self,gr_out,*args,mask_in=None,**kwargs):
        &#34;&#34;&#34;
        Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataarray 
        coordinates to gr_out coordinates

        Parameters
        ----------
        gr_out : dataset
            dataset containing the coordinates to regrid on
        *args : 
            any argument passed to xesmf.Regridder method
        mask_in : None or dataarray
            mask to be applied on the data to regrid
        *kwargs : 
            any keyword argument passed to xesmf.Regridder method

        Returns
        -------
        regridder : xesmf.Regridder instance
            regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates
        &#34;&#34;&#34;

        ds=xr.Dataset({&#39;data&#39;:self._obj})
        return ds.xgeo.regridder(gr_out,*args,mask_in,**kwargs)
    
    def regrid(self,regridder,*args,**kwargs):
        &#34;&#34;&#34;
        Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates

        Parameters
        ----------
        regridder : xesmf.Regridder instance
            regridder set with the xgeo.regridder method

        *args : 
            any argument passed to xesmf regridder method
        *kwargs : 
            any keyword argument passed to xesmf regridder method

        Returns
        -------
        regrid : dataset
            dataset regridded to gr_out coordinates

        Example
        -------
        &gt;&gt;&gt;ds_out = xr.Dataset({&#34;latitude&#34;:([&#34;latitude&#34;],np.arange(-89.5,90,1.)),
        &gt;&gt;&gt;                     &#34;longitude&#34;:([&#34;longitude&#34;],np.arange(-179.5,180,1.))})
        &gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&#34;conservative_normed&#34;,periodic=True)
        &gt;&gt;&gt;out = data.xgeo.regrid(regridder)
        &#34;&#34;&#34;        
        return regridder(self._obj,*args,**kwargs)

    def filter(self, filter_name=lanczos,q=3, **kwargs):
        &#34;&#34;&#34;
        Apply a specified filter on all the time-dependent datarray
        Boundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data
        Available filters are in the .utils python file
        
        Parameters
        ----------
        filter_name : function
            filter function name, from the .utils file
        q : int
            order of the polyfit to handle boundary effects
        **kwargs :
            keyword arguments for the chosen filter
            
        Returns
        -------
        filtered : filtered dataset
        
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).temp
        &gt;&gt;&gt;data.xgeo.filter(lanczos,q=3,coupure=12,order=2)
        
        &#34;&#34;&#34;        
        return filter(self._obj,filter_name=filter_name,q=q,**kwargs)
    
    def interp_time(self,other,**kwargs):
        &#34;&#34;&#34;
        Interpolate dataarray at the same dates than other
        
        Parameter
        ---------
        other : dataarray
            must have a time dimension
            
        Return
        ------
        interpolated : dataarray
            new dataarray interpolated
        &#34;&#34;&#34;        
        return interp_time(self._obj,other,**kwargs)
    
    def plot_timeseries_uncertainty(self, **kwargs):
        plot_timeseries_uncertainty(self._obj, **kwargs)
        
    def to_datetime(self,input_type):
        &#34;&#34;&#34;
        Convert dataarray time format to standard pandas time format
        
        Parameter
        ---------
        input_type : string
            Can be &#39;frac_year&#39; or &#39;360_day&#39;
            
        Return
        ------
        converted : dataarray
            new dataarray with the time dimension in a standard pandas format
        &#34;&#34;&#34;
        return to_datetime(self._obj,input_type)        

    def diff_3pts(self,dim):
        &#34;&#34;&#34;
        Derivative formula along the selected dimension, returning on each point the linear regression on the three points
        defined by the selected point and its two neighbours
        &#34;&#34;&#34;
        return diff_3pts(self._obj,dim)

    def to_difgri(self,dir_out,prefix,suffix):
        to_difgri(self._obj,dir_out,prefix,suffix)

    def trend(self):
        &#34;&#34;&#34;
        Perform a linear regression on the data, and returns the slope coefficient
        &#34;&#34;&#34;
        return trend(self._obj)
    
    def fill_time(self):
        &#34;&#34;&#34;
        Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN
        but real absent points in the timeseries. A linear interpolation is performed at the missing points.
        &#34;&#34;&#34;
        return fill_time(self._obj)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="lenapy.xOcean.OceanArray" href="xOcean.html#lenapy.xOcean.OceanArray">OceanArray</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lenapy.xGeo.GeoArray.climato"><code class="name flex">
<span>def <span class="ident">climato</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform climato analysis on a dataarray
Input data are decomposed into :
annual cycle
semi-annual cycle
trend
mean
residual signal
The returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)
If return_coeffs=True, the coefficients of the decompositions are returned</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>Bool (default=True)</code></dt>
<dd>returns residual signal</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>Bool (default=True)</code></dt>
<dd>returns mean signal</dd>
<dt><strong><code>trend</code></strong> :&ensp;<code>Bool (default=True)</code></dt>
<dd>returns trend</dd>
<dt><strong><code>cycle</code></strong> :&ensp;<code>Bool (default=False)</code></dt>
<dd>return annual and semi-annual cycles</dd>
<dt><strong><code>return_coeffs</code></strong> :&ensp;<code>Bool (default=False)</code></dt>
<dd>returns cycle coefficient, mean and trend
retourne en plus les coefficients des cycles et de la tendance linéaire</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>climato</code></strong> :&ensp;<code>dataarray</code></dt>
<dd>a dataarray with the same structure as the input, with modified data according to the chosen options</dd>
<dt><code>if return_coeffs=True, an extra dataset is provided with the coefficients</code> of <code>the decomposition</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc').ohc
output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)</p>
</blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def climato(self,**kwargs):
    &#34;&#34;&#34;
    Perform climato analysis on a dataarray
    Input data are decomposed into :
        annual cycle
        semi-annual cycle
        trend
        mean
        residual signal
    The returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)
    If return_coeffs=True, the coefficients of the decompositions are returned
    
    Parameters
    ----------
    signal : Bool (default=True)
        returns residual signal
    mean : Bool (default=True)
        returns mean signal
    trend : Bool (default=True)
        returns trend
    cycle : Bool (default=False)
        return annual and semi-annual cycles
    return_coeffs : Bool (default=False)
        returns cycle coefficient, mean and trend
        retourne en plus les coefficients des cycles et de la tendance linéaire
        
    Returns
    -------
    climato : dataarray
        a dataarray with the same structure as the input, with modified data according to the chosen options
    if return_coeffs=True, an extra dataset is provided with the coefficients of the decomposition
    
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;).ohc
    &gt;&gt;&gt;output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)
    &#34;&#34;&#34;
    return climato(self._obj,**kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.diff_3pts"><code class="name flex">
<span>def <span class="ident">diff_3pts</span></span>(<span>self, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Derivative formula along the selected dimension, returning on each point the linear regression on the three points
defined by the selected point and its two neighbours</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff_3pts(self,dim):
    &#34;&#34;&#34;
    Derivative formula along the selected dimension, returning on each point the linear regression on the three points
    defined by the selected point and its two neighbours
    &#34;&#34;&#34;
    return diff_3pts(self._obj,dim)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.fill_time"><code class="name flex">
<span>def <span class="ident">fill_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN
but real absent points in the timeseries. A linear interpolation is performed at the missing points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_time(self):
    &#34;&#34;&#34;
    Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN
    but real absent points in the timeseries. A linear interpolation is performed at the missing points.
    &#34;&#34;&#34;
    return fill_time(self._obj)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, filter_name=&lt;function lanczos&gt;, q=3, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a specified filter on all the time-dependent datarray
Boundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data
Available filters are in the .utils python file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filter_name</code></strong> :&ensp;<code>function</code></dt>
<dd>filter function name, from the .utils file</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>int</code></dt>
<dd>order of the polyfit to handle boundary effects</dd>
</dl>
<p>**kwargs :
keyword arguments for the chosen filter</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filtered</code></strong> :&ensp;<code>filtered dataset</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc').temp
data.xgeo.filter(lanczos,q=3,coupure=12,order=2)</p>
</blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, filter_name=lanczos,q=3, **kwargs):
    &#34;&#34;&#34;
    Apply a specified filter on all the time-dependent datarray
    Boundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data
    Available filters are in the .utils python file
    
    Parameters
    ----------
    filter_name : function
        filter function name, from the .utils file
    q : int
        order of the polyfit to handle boundary effects
    **kwargs :
        keyword arguments for the chosen filter
        
    Returns
    -------
    filtered : filtered dataset
    
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).temp
    &gt;&gt;&gt;data.xgeo.filter(lanczos,q=3,coupure=12,order=2)
    
    &#34;&#34;&#34;        
    return filter(self._obj,filter_name=filter_name,q=q,**kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.interp_time"><code class="name flex">
<span>def <span class="ident">interp_time</span></span>(<span>self, other, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate dataarray at the same dates than other</p>
<h2 id="parameter">Parameter</h2>
<p>other : dataarray
must have a time dimension</p>
<h2 id="return">Return</h2>
<p>interpolated : dataarray
new dataarray interpolated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp_time(self,other,**kwargs):
    &#34;&#34;&#34;
    Interpolate dataarray at the same dates than other
    
    Parameter
    ---------
    other : dataarray
        must have a time dimension
        
    Return
    ------
    interpolated : dataarray
        new dataarray interpolated
    &#34;&#34;&#34;        
    return interp_time(self._obj,other,**kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.isosurface"><code class="name flex">
<span>def <span class="ident">isosurface</span></span>(<span>self, target, dim, upper=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the isosurface along the specified coordinate at the value defined
by the target.
Data is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,
starting from the end (bottom) if upper=False, or from the beggining (top) if upper=True</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target</code></strong> :&ensp;<code>float</code></dt>
<dd>criterion value to be satisfied at the iso surface</dd>
<dt><strong><code>dim</code></strong> :&ensp;<code>string</code></dt>
<dd>dimension along which to compute the isosurface</dd>
<dt><strong><code>upper</code></strong> :&ensp;<code>boolean (default=False)</code></dt>
<dd>order to perform the research of the criterion value. If False, from the end, if True, form the beggining</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>isosurface</code></strong> :&ensp;<code>dataarray</code></dt>
<dd>Dataarray containing the isosurface along the dimension dim on which data=target.</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc').temp
data.isosurface(3,'depth')
<xarray.DataArray (latitude: 90, longitude: 180)>
dask.array&lt;_nanmax_skip-aggregate, shape=(90, 180), dtype=float64, chunksize=(90, 180), chunktype=numpy.ndarray&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="coordinates">Coordinates</h2>
<ul>
<li>latitude
(latitude) float32 -44.5 -43.5 -42.5 -41.5 &hellip; 42.5 43.5 44.5</li>
<li>longitude
(longitude) float32 1.0 2.0 3.0 4.0 &hellip; 177.0 178.0 179.0 180.0
time
datetime64[ns] 2005-01-15</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isosurface(self, target, dim, upper=False):   
    &#34;&#34;&#34;
    Compute the isosurface along the specified coordinate at the value defined  by the target.
    Data is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,
    starting from the end (bottom) if upper=False, or from the beggining (top) if upper=True
    
    Parameters
    ----------
    target : float
        criterion value to be satisfied at the iso surface
    dim : string
        dimension along which to compute the isosurface
    upper : boolean (default=False)
        order to perform the research of the criterion value. If False, from the end, if True, form the beggining
        
    Returns
    -------
    isosurface : dataarray
        Dataarray containing the isosurface along the dimension dim on which data=target.
            
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).temp
    &gt;&gt;&gt;data.isosurface(3,&#39;depth&#39;)
    &lt;xarray.DataArray (latitude: 90, longitude: 180)&gt;
    dask.array&lt;_nanmax_skip-aggregate, shape=(90, 180), dtype=float64, chunksize=(90, 180), chunktype=numpy.ndarray&gt;
    Coordinates:
      * latitude   (latitude) float32 -44.5 -43.5 -42.5 -41.5 ... 42.5 43.5 44.5
      * longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 177.0 178.0 179.0 180.0
        time       datetime64[ns] 2005-01-15
    &#34;&#34;&#34;        
    return isosurface(self._obj,target,dim,upper=upper)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self, *args, weights=None, mask=True, na_eq_zero=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the averaged value of dataarray along specified dimension, applying specified weights</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>list</code></dt>
<dd>list of the dimensions along which to average</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>None</code> or <code>list</code> or <code>dataarray</code></dt>
<dd>if None, no weight is applyed
if 'latitude' or 'depth', a weight is applyed as the cosine of the latitude or
the thickness of the layer
if dataarray :
input data are multiplied by this dataarray before averaging</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>None</code> or <code>dataarray</code></dt>
<dd>mask to be applyed before averaging</dd>
<dt><strong><code>na_eq_zero</code></strong> :&ensp;<code>boolean (default=False)</code></dt>
<dd>replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>keyword arguments</code></dt>
<dd>any keyword arguments passe to the native xarray.mean function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>averaged</code></strong> :&ensp;<code>dataarray</code></dt>
<dd>dataarray averaged according to specified options</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc').temp
avg = data.xgeo.mean(['latitude','longitude'],weights=['latitude'],na_eq_zero=True)</p>
</blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self,*args,weights=None,mask=True,na_eq_zero=False,**kwargs):
    &#34;&#34;&#34;
    Returns the averaged value of dataarray along specified dimension, applying specified weights
    
    Parameters
    ----------
    *args : list
        list of the dimensions along which to average
    
    weights : None or list or dataarray
        if None, no weight is applyed
        if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                the thickness of the layer
        if dataarray :
                input data are multiplied by this dataarray before averaging
    mask : None or dataarray
        mask to be applyed before averaging
    na_eq_zero : boolean (default=False)
        replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones
    **kwargs : keyword arguments
        any keyword arguments passe to the native xarray.mean function
        
    Returns
    -------
    averaged : dataarray
        dataarray averaged according to specified options
        
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).temp
    &gt;&gt;&gt;avg = data.xgeo.mean([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;],na_eq_zero=True)
        
    &#34;&#34;&#34;
    argmean=set(np.ravel(*args)).intersection(list(self._obj.coords))
    data=self._obj.where(mask)
    if na_eq_zero:
        data=data.fillna(0.)
        
    if len(argmean)==0:
        argmean=None
    if type(weights)==type(None):
        # Moyenne simple
        return data.mean(argmean,**kwargs)
    elif type(weights)==list or type(weights)==str:
        w=1
        if &#39;latitude&#39; in weights and &#39;latitude&#39; in self._obj.coords:
            # poids = cos(latitude)
            w=np.cos(np.radians(self._obj.latitude))
        if &#39;depth&#39; in weights and &#39;depth&#39; in self._obj.coords:
            # poids *= épaisseur des couches (l&#39;épaisseur de la première couche est la première profondeur)
            w=w*xr.concat((self._obj.depth.isel(depth=0),self._obj.depth.diff(dim=&#39;depth&#39;)),dim=&#39;depth&#39;)
        return data.weighted(w).mean(argmean,**kwargs)
    else:
        # matrice de poids définie par l&#39;utilisateur
        return data.weighted(weights).mean(argmean,**kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.plot_timeseries_uncertainty"><code class="name flex">
<span>def <span class="ident">plot_timeseries_uncertainty</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_timeseries_uncertainty(self, **kwargs):
    plot_timeseries_uncertainty(self._obj, **kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.regrid"><code class="name flex">
<span>def <span class="ident">regrid</span></span>(<span>self, regridder, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>regridder</code></strong> :&ensp;<code>xesmf.Regridder instance</code></dt>
<dd>regridder set with the xgeo.regridder method</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>any argument passed to xesmf regridder method</dd>
<dt><strong><code>*kwargs</code></strong></dt>
<dd>any keyword argument passed to xesmf regridder method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>regrid</code></strong> :&ensp;<code>dataset</code></dt>
<dd>dataset regridded to gr_out coordinates</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>ds_out = xr.Dataset({"latitude":(["latitude"],np.arange(-89.5,90,1.)),</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-python-repl">&gt;&gt;&gt;                     &quot;longitude&quot;:([&quot;longitude&quot;],np.arange(-179.5,180,1.))})
&gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&quot;conservative_normed&quot;,periodic=True)
&gt;&gt;&gt;out = data.xgeo.regrid(regridder)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regrid(self,regridder,*args,**kwargs):
    &#34;&#34;&#34;
    Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates

    Parameters
    ----------
    regridder : xesmf.Regridder instance
        regridder set with the xgeo.regridder method

    *args : 
        any argument passed to xesmf regridder method
    *kwargs : 
        any keyword argument passed to xesmf regridder method

    Returns
    -------
    regrid : dataset
        dataset regridded to gr_out coordinates

    Example
    -------
    &gt;&gt;&gt;ds_out = xr.Dataset({&#34;latitude&#34;:([&#34;latitude&#34;],np.arange(-89.5,90,1.)),
    &gt;&gt;&gt;                     &#34;longitude&#34;:([&#34;longitude&#34;],np.arange(-179.5,180,1.))})
    &gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&#34;conservative_normed&#34;,periodic=True)
    &gt;&gt;&gt;out = data.xgeo.regrid(regridder)
    &#34;&#34;&#34;        
    return regridder(self._obj,*args,**kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.regridder"><code class="name flex">
<span>def <span class="ident">regridder</span></span>(<span>self, gr_out, *args, mask_in=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataarray
coordinates to gr_out coordinates</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gr_out</code></strong> :&ensp;<code>dataset</code></dt>
<dd>dataset containing the coordinates to regrid on</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>any argument passed to xesmf.Regridder method</dd>
<dt><strong><code>mask_in</code></strong> :&ensp;<code>None</code> or <code>dataarray</code></dt>
<dd>mask to be applied on the data to regrid</dd>
<dt><strong><code>*kwargs</code></strong></dt>
<dd>any keyword argument passed to xesmf.Regridder method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>regridder</code></strong> :&ensp;<code>xesmf.Regridder instance</code></dt>
<dd>regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regridder(self,gr_out,*args,mask_in=None,**kwargs):
    &#34;&#34;&#34;
    Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataarray 
    coordinates to gr_out coordinates

    Parameters
    ----------
    gr_out : dataset
        dataset containing the coordinates to regrid on
    *args : 
        any argument passed to xesmf.Regridder method
    mask_in : None or dataarray
        mask to be applied on the data to regrid
    *kwargs : 
        any keyword argument passed to xesmf.Regridder method

    Returns
    -------
    regridder : xesmf.Regridder instance
        regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates
    &#34;&#34;&#34;

    ds=xr.Dataset({&#39;data&#39;:self._obj})
    return ds.xgeo.regridder(gr_out,*args,mask_in,**kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>self, *args, weights=None, mask=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of dataarray along specified dimension, applying specified weights</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>list</code></dt>
<dd>list of the dimensions along which to sum</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>None</code> or <code>list</code> or <code>dataarray</code></dt>
<dd>if None, no weight is applyed
if 'latitude' or 'depth', a weight is applyed as the cosine of the latitude or
the thickness of the layer
if dataarray :
input data are multiplied by this dataarray before summing</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>None</code> or <code>dataarray</code></dt>
<dd>mask to be applyed before summing</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>keyword arguments</code></dt>
<dd>any keyword arguments passe to the native xarray.sum function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>averaged</code></strong> :&ensp;<code>dataarray</code></dt>
<dd>dataarray summed according to specified options</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc').heat
avg = data.xgeo.sum(['latitude','longitude'],weights=['latitude'])</p>
</blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(self,*args,weights=None,mask=True,**kwargs):
    &#34;&#34;&#34;
    Returns the sum of dataarray along specified dimension, applying specified weights
    
    Parameters
    ----------
    *args : list
        list of the dimensions along which to sum
    
    weights : None or list or dataarray
        if None, no weight is applyed
        if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                the thickness of the layer
        if dataarray :
                input data are multiplied by this dataarray before summing
    mask : None or dataarray
        mask to be applyed before summing
    **kwargs : keyword arguments
        any keyword arguments passe to the native xarray.sum function
        
    Returns
    -------
    averaged : dataarray
        dataarray summed according to specified options
        
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;).heat
    &gt;&gt;&gt;avg = data.xgeo.sum([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;])
        
    &#34;&#34;&#34;       
    argsum=set(np.ravel(*args)).intersection(list(self._obj.coords))
    data=self._obj.where(mask)        
    if type(weights)==type(None):
        # Somme simple
        return data.sum(argsum,**kwargs)
    elif type(weights)==list or type(weights)==str:
        w=1
        if &#39;latitude&#39; in weights and &#39;latitude&#39; in self._obj.coords:
            # poids = cos(latitude)
            w=np.cos(np.radians(self._obj.latitude))
        if &#39;depth&#39; in weights and &#39;depth&#39; in self._obj.coords:
            # poids *= épaisseur des couches (l&#39;épaisseur de la première couche est la première profondeur)
            w=w*xr.concat((self._obj.depth.isel(depth=0),self._obj.depth.diff(dim=&#39;depth&#39;)),dim=&#39;depth&#39;)
        return data.weighted(w).sum(argsum,**kwargs)
    else:
        # matrice de poids définie par l&#39;utilisateur
        return data.weighted(weights).sum(argsum,**kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.to_datetime"><code class="name flex">
<span>def <span class="ident">to_datetime</span></span>(<span>self, input_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert dataarray time format to standard pandas time format</p>
<h2 id="parameter">Parameter</h2>
<p>input_type : string
Can be 'frac_year' or '360_day'</p>
<h2 id="return">Return</h2>
<p>converted : dataarray
new dataarray with the time dimension in a standard pandas format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_datetime(self,input_type):
    &#34;&#34;&#34;
    Convert dataarray time format to standard pandas time format
    
    Parameter
    ---------
    input_type : string
        Can be &#39;frac_year&#39; or &#39;360_day&#39;
        
    Return
    ------
    converted : dataarray
        new dataarray with the time dimension in a standard pandas format
    &#34;&#34;&#34;
    return to_datetime(self._obj,input_type)        </code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.to_difgri"><code class="name flex">
<span>def <span class="ident">to_difgri</span></span>(<span>self, dir_out, prefix, suffix)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_difgri(self,dir_out,prefix,suffix):
    to_difgri(self._obj,dir_out,prefix,suffix)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoArray.trend"><code class="name flex">
<span>def <span class="ident">trend</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a linear regression on the data, and returns the slope coefficient</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trend(self):
    &#34;&#34;&#34;
    Perform a linear regression on the data, and returns the slope coefficient
    &#34;&#34;&#34;
    return trend(self._obj)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lenapy.xGeo.GeoSet"><code class="flex name class">
<span>class <span class="ident">GeoSet</span></span>
<span>(</span><span>xarray_obj)</span>
</code></dt>
<dd>
<div class="desc"><p>This class implements an extension of any dataset to add some usefull methods often used in earth science data handling</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@xr.register_dataset_accessor(&#34;xgeo&#34;)
class GeoSet:
    &#34;&#34;&#34;
    This class implements an extension of any dataset to add some usefull methods often used in earth science data handling
    &#34;&#34;&#34;
    def __init__(self, xarray_obj):
        self._obj = xarray_obj
        
    def climato(self,**kwargs):
        &#34;&#34;&#34;
        Perform climato analysis on all the variables in a dataset
        Input data are decomposed into :
            annual cycle
            semi-annual cycle
            trend
            mean
            residual signal
        The returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)
        If return_coeffs=True, the coefficients of the decompositions are returned
        
        Parameters
        ----------
        signal : Bool (default=True)
            returns residual signal
        mean : Bool (default=True)
            returns mean signal
        trend : Bool (default=True)
            returns trend
        cycle : Bool (default=False)
            return annual and semi-annual cycles
        return_coeffs : Bool (default=False)
            returns cycle coefficient, mean and trend
            retourne en plus les coefficients des cycles et de la tendance linéaire
            
        Returns
        -------
        climato : dataset
            a dataset with the same structure as the input, with modified data according to the chosen options
        if return_coeffs=True, an extra dataset is provided with the coefficients of the decomposition
        
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;)
        &gt;&gt;&gt;output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)
        &#34;&#34;&#34;

        # Pour toutes les données dépendant du temps, retourne l&#39;analyse de la climato
        res={}
        for var in self._obj.data_vars:
            if &#39;time&#39; in self._obj[var].coords:
                res[var]=climato(self._obj[var],**kwargs)
            else:
                res[var]=self._obj[var]
        return xr.Dataset(res)

    def mean(self,*args,**kwargs):
        &#34;&#34;&#34;
        Returns the averaged value of all variables in dataset along specified dimension, applying specified weights
        
        Parameters
        ----------
        *args : list
            list of the dimensions along which to average
        
        weights : None or list or dataarray
            if None, no weight is applyed
            if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                    the thickness of the layer
            if dataarray :
                    input data are multiplied by this dataarray before averaging
        mask : None or dataarray
            mask to be applyed befire averaging
        na_eq_zero : boolean (default=False)
            replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones
        **kwargs : keyword arguments
            any keyword arguments passe to the native xarray.mean function
            
        Returns
        -------
        averaged : dataset
            dataset with all variables averaged according to specified options
            
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;)
        &gt;&gt;&gt;avg = data.xgeo.mean([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;],na_eq_zero=True)
            
        &#34;&#34;&#34;
        res={}
        for var in self._obj.data_vars:
            res[var]=self._obj[var].xgeo.mean(*args,**kwargs)
        return xr.Dataset(res)

    def sum(self,*args,**kwargs):
        &#34;&#34;&#34;
        Returns the sum for all variables in dataset along specified dimension, applying specified weights
        
        Parameters
        ----------
        *args : list
            list of the dimensions along which to sum
        
        weights : None or list or dataarray
            if None, no weight is applyed
            if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                    the thickness of the layer
            if dataarray :
                    input data are multiplied by this dataarray before summing
        mask : None or dataarray
            mask to be applyed before summing
        **kwargs : keyword arguments
            any keyword arguments passe to the native xarray.sum function
            
        Returns
        -------
        averaged : dataset
            dataset with all variablessummed according to specified options
            
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;)
        &gt;&gt;&gt;avg = data.xgeo.sum([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;])
            
        &#34;&#34;&#34;             
        res={}
        for var in self._obj.data_vars:
            res[var]=self._obj[var].xgeo.sum(*args,**kwargs)
        return xr.Dataset(res)
    
    
    def isosurface(self, dim, criterion, upper=False):
        &#34;&#34;&#34;
        Compute the isosurface along the specified coordinate at the value defined  by the kwarg field=value.
        For example, we want to compute the isosurface defined by a temperature of 10°C along depth dimension.
        All data variables of the data set are interpolated on this iso surface
        Data is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,
        starting from the end (bottom) if upper=False, or from the beggining (top) if upper=True
        
        Parameters
        ----------
        dim : string
            dimension along which to compute the isosurface
        criterion : dict
            one-entry dictionnary with the key equal to a variable of the dataset, and the value equal to the isosurface criterion
        upper : boolean (default=False)
            order to perform the research of the criterion value. If False, from the end, if True, form the beggining
            
        Returns
        -------
        isosurface : dataset
            Dataset with all the variables interpolated at the criterion value along chosen dimension. The variables chosen for
                criterion should contain a constant value equal to the criterion. the dimension chosen for the isosurface computation
                is filled with the isosurface itself.
                
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;)
        &gt;&gt;&gt;data.isosurface(&#39;depth&#39;,dict(temp=3))
        &lt;xarray.Dataset&gt;
        Dimensions:    (latitude: 90, longitude: 180)
        Coordinates:
          * latitude   (latitude) float32 -44.5 -43.5 -42.5 -41.5 ... 42.5 43.5 44.5
          * longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 177.0 178.0 179.0 180.0
            time       datetime64[ns] 2005-01-15
            depth      (latitude, longitude) float64 918.6 745.8 704.8 ... 912.2 920.0
        Data variables:
            depth_iso  (latitude, longitude) float64 918.6 745.8 704.8 ... 912.2 920.0
            temp       (latitude, longitude) float64 3.0 3.0 3.0 3.0 ... 3.0 3.0 3.0 3.0
            SA         (latitude, longitude) float64 34.48 34.39 34.39 ... 34.53 34.52

        
        &#34;&#34;&#34;
        # Calcule l&#39;isosurface selon la coordonnée &#39;dim&#39; pour le champ défini par le dictionnaire **kwargs (ex : temp=10)
        # Retourne tous les champs interpolés sur cette isosurface (pour ceux ayant &#34;dim&#34; en coordonnée), ainsi que l&#39;isosurface elle-même
        k=list(criterion.keys())[0]
        if not(k in self._obj.data_vars):
            raise KeyError(&#34;%s not in %s&#34;%(criterion[0],list(data_vars)))
            
        r=isosurface(self._obj[k],criterion[k],dim, upper=upper)
        res=xr.Dataset()
        for var in self._obj.data_vars:
            if dim in self._obj[var].coords:
                res[var]=self._obj[var].interp({dim:r})
            else:
                res[var]=self._obj[var]

        return res

    def regridder(self,gr_out,*args,mask_in=None,**kwargs):
        &#34;&#34;&#34;
        Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataset 
        coordinates to gr_out coordinates

        Parameters
        ----------
        gr_out : dataset
            dataset containing the coordinates to regrid on
        *args : 
            any argument passed to xesmf.Regridder method
        mask_in : None or dataarray
            mask to be applied on the data to regrid
        *kwargs : 
            any keyword argument passed to xesmf.Regridder method

        Returns
        -------
        regridder : xesmf.Regridder instance
            regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates
        &#34;&#34;&#34;
        if not &#39;latitude&#39; in gr_out.coords: raise AssertionError(&#39;The latitude coordinates does not exist&#39;)
        if not &#39;longitude&#39; in gr_out.coords: raise AssertionError(&#39;The longitude coordinates does not exist&#39;)

        ds=self._obj
        if type(mask_in)==xr.DataArray:
            ds[&#39;mask&#39;]=mask_in
            
        ds_out=xr.Dataset({
        &#34;latitude&#34;:gr_out.latitude,
        &#34;longitude&#34;:gr_out.longitude
        })

        return xe.Regridder(ds,ds_out,*args,**kwargs)
    
    def regrid(self,regridder,*args,**kwargs):
        &#34;&#34;&#34;
        Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates

        Parameters
        ----------
        regridder : xesmf.Regridder instance
            regridder set with the xgeo.regridder method

        *args : 
            any argument passed to xesmf regridder method
        *kwargs : 
            any keyword argument passed to xesmf regridder method

        Returns
        -------
        regrid : dataset
            dataset regridded to gr_out coordinates

        Example
        -------
        &gt;&gt;&gt;ds_out = xr.Dataset({&#34;latitude&#34;:([&#34;latitude&#34;],np.arange(-89.5,90,1.)),
        &gt;&gt;&gt;                     &#34;longitude&#34;:([&#34;longitude&#34;],np.arange(-179.5,180,1.))})
        &gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&#34;conservative_normed&#34;,periodic=True)
        &gt;&gt;&gt;out = data.xgeo.regrid(regridder)
        &#34;&#34;&#34;
        return regridder(self._obj,*args,**kwargs)
    
    def filter(self, filter_name=lanczos,q=3, **kwargs):
        &#34;&#34;&#34;
        Apply a specified filter on all the time-dependent data in the dataset
        Boundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data
        Available filters are in the .utils python file
        
        Parameters
        ----------
        filter_name : function
            filter function name, from the .utils file
        q : int
            order of the polyfit to handle boundary effects
        **kwargs :
            keyword arguments for the chosen filter
            
        Returns
        -------
        filtered : filtered dataset
        
        Example
        -------
        &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;)
        &gt;&gt;&gt;data.xgeo.filter(lanczos,q=3,coupure=12,order=2)
        
        &#34;&#34;&#34;
        res={}
        for var in self._obj.data_vars:
            if &#39;time&#39; in self._obj[var].coords:
                res[var]=self._obj[var].xgeo.filter(filter_name=filter_name,q=q,**kwargs)
            else:
                res[var]=self._obj[var]
        return xr.Dataset(res)

    def interp_time(self,other,**kwargs):
        &#34;&#34;&#34;
        Interpolate dataarray at the same dates than other
        
        Parameter
        ---------
        other : dataarray
            must have a time dimension
            
        Return
        ------
        interpolated : dataarray
            new dataarray interpolated
        &#34;&#34;&#34;        
        res={}
        for var in self._obj.data_vars:
            if &#39;time&#39; in self._obj[var].coords:
                res[var]=self._obj[var].xgeo.interp_time(other,**kwargs)
            else:
                res[var]=self._obj[var]
        return xr.Dataset(res)

    def to_datetime(self,input_type):
        &#34;&#34;&#34;
        Convert dataset time format to standard pandas time format
        
        Parameter
        ---------
        input_type : string
            Can be &#39;frac_year&#39; or &#39;360_day&#39;
            
        Return
        ------
        converted : dataset
            new dataset with the time dimension in a standard pandas format
        &#34;&#34;&#34;
        return to_datetime(self._obj,input_type)        

    def fill_time(self):
        &#34;&#34;&#34;
        Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN
        but real absent points in the timeseries. A linear interpolation is performed at the missing points.
        &#34;&#34;&#34;
        return fill_time(self._obj)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="lenapy.xOcean.OceanSet" href="xOcean.html#lenapy.xOcean.OceanSet">OceanSet</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lenapy.xGeo.GeoSet.climato"><code class="name flex">
<span>def <span class="ident">climato</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform climato analysis on all the variables in a dataset
Input data are decomposed into :
annual cycle
semi-annual cycle
trend
mean
residual signal
The returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)
If return_coeffs=True, the coefficients of the decompositions are returned</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code>Bool (default=True)</code></dt>
<dd>returns residual signal</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>Bool (default=True)</code></dt>
<dd>returns mean signal</dd>
<dt><strong><code>trend</code></strong> :&ensp;<code>Bool (default=True)</code></dt>
<dd>returns trend</dd>
<dt><strong><code>cycle</code></strong> :&ensp;<code>Bool (default=False)</code></dt>
<dd>return annual and semi-annual cycles</dd>
<dt><strong><code>return_coeffs</code></strong> :&ensp;<code>Bool (default=False)</code></dt>
<dd>returns cycle coefficient, mean and trend
retourne en plus les coefficients des cycles et de la tendance linéaire</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>climato</code></strong> :&ensp;<code>dataset</code></dt>
<dd>a dataset with the same structure as the input, with modified data according to the chosen options</dd>
<dt><code>if return_coeffs=True, an extra dataset is provided with the coefficients</code> of <code>the decomposition</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc')
output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)</p>
</blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def climato(self,**kwargs):
    &#34;&#34;&#34;
    Perform climato analysis on all the variables in a dataset
    Input data are decomposed into :
        annual cycle
        semi-annual cycle
        trend
        mean
        residual signal
    The returned data are a combination of these elements depending on passed arguments (signal, mean, trend, cycle)
    If return_coeffs=True, the coefficients of the decompositions are returned
    
    Parameters
    ----------
    signal : Bool (default=True)
        returns residual signal
    mean : Bool (default=True)
        returns mean signal
    trend : Bool (default=True)
        returns trend
    cycle : Bool (default=False)
        return annual and semi-annual cycles
    return_coeffs : Bool (default=False)
        returns cycle coefficient, mean and trend
        retourne en plus les coefficients des cycles et de la tendance linéaire
        
    Returns
    -------
    climato : dataset
        a dataset with the same structure as the input, with modified data according to the chosen options
    if return_coeffs=True, an extra dataset is provided with the coefficients of the decomposition
    
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;)
    &gt;&gt;&gt;output,coeffs = data.xgeo.climato(mean=True, trend=True, signal=True,return_coeffs=True)
    &#34;&#34;&#34;

    # Pour toutes les données dépendant du temps, retourne l&#39;analyse de la climato
    res={}
    for var in self._obj.data_vars:
        if &#39;time&#39; in self._obj[var].coords:
            res[var]=climato(self._obj[var],**kwargs)
        else:
            res[var]=self._obj[var]
    return xr.Dataset(res)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoSet.fill_time"><code class="name flex">
<span>def <span class="ident">fill_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN
but real absent points in the timeseries. A linear interpolation is performed at the missing points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_time(self):
    &#34;&#34;&#34;
    Fill missing values in a timeseries in adding some new points, by respecting the time sampling. Missing values are not NaN
    but real absent points in the timeseries. A linear interpolation is performed at the missing points.
    &#34;&#34;&#34;
    return fill_time(self._obj)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoSet.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, filter_name=&lt;function lanczos&gt;, q=3, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a specified filter on all the time-dependent data in the dataset
Boundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data
Available filters are in the .utils python file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filter_name</code></strong> :&ensp;<code>function</code></dt>
<dd>filter function name, from the .utils file</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>int</code></dt>
<dd>order of the polyfit to handle boundary effects</dd>
</dl>
<p>**kwargs :
keyword arguments for the chosen filter</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filtered</code></strong> :&ensp;<code>filtered dataset</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc')
data.xgeo.filter(lanczos,q=3,coupure=12,order=2)</p>
</blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, filter_name=lanczos,q=3, **kwargs):
    &#34;&#34;&#34;
    Apply a specified filter on all the time-dependent data in the dataset
    Boundaries are handled by operating a mirror operation on the residual data after removing a q-order polyfit from the data
    Available filters are in the .utils python file
    
    Parameters
    ----------
    filter_name : function
        filter function name, from the .utils file
    q : int
        order of the polyfit to handle boundary effects
    **kwargs :
        keyword arguments for the chosen filter
        
    Returns
    -------
    filtered : filtered dataset
    
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;)
    &gt;&gt;&gt;data.xgeo.filter(lanczos,q=3,coupure=12,order=2)
    
    &#34;&#34;&#34;
    res={}
    for var in self._obj.data_vars:
        if &#39;time&#39; in self._obj[var].coords:
            res[var]=self._obj[var].xgeo.filter(filter_name=filter_name,q=q,**kwargs)
        else:
            res[var]=self._obj[var]
    return xr.Dataset(res)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoSet.interp_time"><code class="name flex">
<span>def <span class="ident">interp_time</span></span>(<span>self, other, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate dataarray at the same dates than other</p>
<h2 id="parameter">Parameter</h2>
<p>other : dataarray
must have a time dimension</p>
<h2 id="return">Return</h2>
<p>interpolated : dataarray
new dataarray interpolated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp_time(self,other,**kwargs):
    &#34;&#34;&#34;
    Interpolate dataarray at the same dates than other
    
    Parameter
    ---------
    other : dataarray
        must have a time dimension
        
    Return
    ------
    interpolated : dataarray
        new dataarray interpolated
    &#34;&#34;&#34;        
    res={}
    for var in self._obj.data_vars:
        if &#39;time&#39; in self._obj[var].coords:
            res[var]=self._obj[var].xgeo.interp_time(other,**kwargs)
        else:
            res[var]=self._obj[var]
    return xr.Dataset(res)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoSet.isosurface"><code class="name flex">
<span>def <span class="ident">isosurface</span></span>(<span>self, dim, criterion, upper=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the isosurface along the specified coordinate at the value defined
by the kwarg field=value.
For example, we want to compute the isosurface defined by a temperature of 10°C along depth dimension.
All data variables of the data set are interpolated on this iso surface
Data is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,
starting from the end (bottom) if upper=False, or from the beggining (top) if upper=True</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>string</code></dt>
<dd>dimension along which to compute the isosurface</dd>
<dt><strong><code>criterion</code></strong> :&ensp;<code>dict</code></dt>
<dd>one-entry dictionnary with the key equal to a variable of the dataset, and the value equal to the isosurface criterion</dd>
<dt><strong><code>upper</code></strong> :&ensp;<code>boolean (default=False)</code></dt>
<dd>order to perform the research of the criterion value. If False, from the end, if True, form the beggining</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>isosurface</code></strong> :&ensp;<code>dataset</code></dt>
<dd>Dataset with all the variables interpolated at the criterion value along chosen dimension. The variables chosen for
criterion should contain a constant value equal to the criterion. the dimension chosen for the isosurface computation
is filled with the isosurface itself.</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc')
data.isosurface('depth',dict(temp=3))
<xarray.Dataset>
Dimensions:
(latitude: 90, longitude: 180)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="coordinates">Coordinates</h2>
<ul>
<li>latitude
(latitude) float32 -44.5 -43.5 -42.5 -41.5 &hellip; 42.5 43.5 44.5</li>
<li>longitude
(longitude) float32 1.0 2.0 3.0 4.0 &hellip; 177.0 178.0 179.0 180.0
time
datetime64[ns] 2005-01-15
depth
(latitude, longitude) float64 918.6 745.8 704.8 &hellip; 912.2 920.0
Data variables:
depth_iso
(latitude, longitude) float64 918.6 745.8 704.8 &hellip; 912.2 920.0
temp
(latitude, longitude) float64 3.0 3.0 3.0 3.0 &hellip; 3.0 3.0 3.0 3.0
SA
(latitude, longitude) float64 34.48 34.39 34.39 &hellip; 34.53 34.52</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isosurface(self, dim, criterion, upper=False):
    &#34;&#34;&#34;
    Compute the isosurface along the specified coordinate at the value defined  by the kwarg field=value.
    For example, we want to compute the isosurface defined by a temperature of 10°C along depth dimension.
    All data variables of the data set are interpolated on this iso surface
    Data is supposed to be monotonic along the chosen dimension. If not, the first fitting value encountered is retained,
    starting from the end (bottom) if upper=False, or from the beggining (top) if upper=True
    
    Parameters
    ----------
    dim : string
        dimension along which to compute the isosurface
    criterion : dict
        one-entry dictionnary with the key equal to a variable of the dataset, and the value equal to the isosurface criterion
    upper : boolean (default=False)
        order to perform the research of the criterion value. If False, from the end, if True, form the beggining
        
    Returns
    -------
    isosurface : dataset
        Dataset with all the variables interpolated at the criterion value along chosen dimension. The variables chosen for
            criterion should contain a constant value equal to the criterion. the dimension chosen for the isosurface computation
            is filled with the isosurface itself.
            
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;)
    &gt;&gt;&gt;data.isosurface(&#39;depth&#39;,dict(temp=3))
    &lt;xarray.Dataset&gt;
    Dimensions:    (latitude: 90, longitude: 180)
    Coordinates:
      * latitude   (latitude) float32 -44.5 -43.5 -42.5 -41.5 ... 42.5 43.5 44.5
      * longitude  (longitude) float32 1.0 2.0 3.0 4.0 ... 177.0 178.0 179.0 180.0
        time       datetime64[ns] 2005-01-15
        depth      (latitude, longitude) float64 918.6 745.8 704.8 ... 912.2 920.0
    Data variables:
        depth_iso  (latitude, longitude) float64 918.6 745.8 704.8 ... 912.2 920.0
        temp       (latitude, longitude) float64 3.0 3.0 3.0 3.0 ... 3.0 3.0 3.0 3.0
        SA         (latitude, longitude) float64 34.48 34.39 34.39 ... 34.53 34.52

    
    &#34;&#34;&#34;
    # Calcule l&#39;isosurface selon la coordonnée &#39;dim&#39; pour le champ défini par le dictionnaire **kwargs (ex : temp=10)
    # Retourne tous les champs interpolés sur cette isosurface (pour ceux ayant &#34;dim&#34; en coordonnée), ainsi que l&#39;isosurface elle-même
    k=list(criterion.keys())[0]
    if not(k in self._obj.data_vars):
        raise KeyError(&#34;%s not in %s&#34;%(criterion[0],list(data_vars)))
        
    r=isosurface(self._obj[k],criterion[k],dim, upper=upper)
    res=xr.Dataset()
    for var in self._obj.data_vars:
        if dim in self._obj[var].coords:
            res[var]=self._obj[var].interp({dim:r})
        else:
            res[var]=self._obj[var]

    return res</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoSet.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the averaged value of all variables in dataset along specified dimension, applying specified weights</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>list</code></dt>
<dd>list of the dimensions along which to average</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>None</code> or <code>list</code> or <code>dataarray</code></dt>
<dd>if None, no weight is applyed
if 'latitude' or 'depth', a weight is applyed as the cosine of the latitude or
the thickness of the layer
if dataarray :
input data are multiplied by this dataarray before averaging</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>None</code> or <code>dataarray</code></dt>
<dd>mask to be applyed befire averaging</dd>
<dt><strong><code>na_eq_zero</code></strong> :&ensp;<code>boolean (default=False)</code></dt>
<dd>replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>keyword arguments</code></dt>
<dd>any keyword arguments passe to the native xarray.mean function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>averaged</code></strong> :&ensp;<code>dataset</code></dt>
<dd>dataset with all variables averaged according to specified options</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/gohc_2020.nc')
avg = data.xgeo.mean(['latitude','longitude'],weights=['latitude'],na_eq_zero=True)</p>
</blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self,*args,**kwargs):
    &#34;&#34;&#34;
    Returns the averaged value of all variables in dataset along specified dimension, applying specified weights
    
    Parameters
    ----------
    *args : list
        list of the dimensions along which to average
    
    weights : None or list or dataarray
        if None, no weight is applyed
        if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                the thickness of the layer
        if dataarray :
                input data are multiplied by this dataarray before averaging
    mask : None or dataarray
        mask to be applyed befire averaging
    na_eq_zero : boolean (default=False)
        replace NaN values by zeros. The averaging is then applyed on all data, and not only valid ones
    **kwargs : keyword arguments
        any keyword arguments passe to the native xarray.mean function
        
    Returns
    -------
    averaged : dataset
        dataset with all variables averaged according to specified options
        
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/gohc_2020.nc&#39;)
    &gt;&gt;&gt;avg = data.xgeo.mean([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;],na_eq_zero=True)
        
    &#34;&#34;&#34;
    res={}
    for var in self._obj.data_vars:
        res[var]=self._obj[var].xgeo.mean(*args,**kwargs)
    return xr.Dataset(res)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoSet.regrid"><code class="name flex">
<span>def <span class="ident">regrid</span></span>(<span>self, regridder, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>regridder</code></strong> :&ensp;<code>xesmf.Regridder instance</code></dt>
<dd>regridder set with the xgeo.regridder method</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>any argument passed to xesmf regridder method</dd>
<dt><strong><code>*kwargs</code></strong></dt>
<dd>any keyword argument passed to xesmf regridder method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>regrid</code></strong> :&ensp;<code>dataset</code></dt>
<dd>dataset regridded to gr_out coordinates</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>ds_out = xr.Dataset({"latitude":(["latitude"],np.arange(-89.5,90,1.)),</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-python-repl">&gt;&gt;&gt;                     &quot;longitude&quot;:([&quot;longitude&quot;],np.arange(-179.5,180,1.))})
&gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&quot;conservative_normed&quot;,periodic=True)
&gt;&gt;&gt;out = data.xgeo.regrid(regridder)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regrid(self,regridder,*args,**kwargs):
    &#34;&#34;&#34;
    Implement the xesmf regrid method to perform regridding from dataset coordinates to gr_out coordinates

    Parameters
    ----------
    regridder : xesmf.Regridder instance
        regridder set with the xgeo.regridder method

    *args : 
        any argument passed to xesmf regridder method
    *kwargs : 
        any keyword argument passed to xesmf regridder method

    Returns
    -------
    regrid : dataset
        dataset regridded to gr_out coordinates

    Example
    -------
    &gt;&gt;&gt;ds_out = xr.Dataset({&#34;latitude&#34;:([&#34;latitude&#34;],np.arange(-89.5,90,1.)),
    &gt;&gt;&gt;                     &#34;longitude&#34;:([&#34;longitude&#34;],np.arange(-179.5,180,1.))})
    &gt;&gt;&gt;regridder = data.xgeo.regridder(ds_out,&#34;conservative_normed&#34;,periodic=True)
    &gt;&gt;&gt;out = data.xgeo.regrid(regridder)
    &#34;&#34;&#34;
    return regridder(self._obj,*args,**kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoSet.regridder"><code class="name flex">
<span>def <span class="ident">regridder</span></span>(<span>self, gr_out, *args, mask_in=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataset
coordinates to gr_out coordinates</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gr_out</code></strong> :&ensp;<code>dataset</code></dt>
<dd>dataset containing the coordinates to regrid on</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>any argument passed to xesmf.Regridder method</dd>
<dt><strong><code>mask_in</code></strong> :&ensp;<code>None</code> or <code>dataarray</code></dt>
<dd>mask to be applied on the data to regrid</dd>
<dt><strong><code>*kwargs</code></strong></dt>
<dd>any keyword argument passed to xesmf.Regridder method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>regridder</code></strong> :&ensp;<code>xesmf.Regridder instance</code></dt>
<dd>regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regridder(self,gr_out,*args,mask_in=None,**kwargs):
    &#34;&#34;&#34;
    Implement a xesmf regridder instance to be used with regrid method to perform regridding from dataset 
    coordinates to gr_out coordinates

    Parameters
    ----------
    gr_out : dataset
        dataset containing the coordinates to regrid on
    *args : 
        any argument passed to xesmf.Regridder method
    mask_in : None or dataarray
        mask to be applied on the data to regrid
    *kwargs : 
        any keyword argument passed to xesmf.Regridder method

    Returns
    -------
    regridder : xesmf.Regridder instance
        regridder to be used with regrid method to perform regridding from dataset coordinates to gr_out coordinates
    &#34;&#34;&#34;
    if not &#39;latitude&#39; in gr_out.coords: raise AssertionError(&#39;The latitude coordinates does not exist&#39;)
    if not &#39;longitude&#39; in gr_out.coords: raise AssertionError(&#39;The longitude coordinates does not exist&#39;)

    ds=self._obj
    if type(mask_in)==xr.DataArray:
        ds[&#39;mask&#39;]=mask_in
        
    ds_out=xr.Dataset({
    &#34;latitude&#34;:gr_out.latitude,
    &#34;longitude&#34;:gr_out.longitude
    })

    return xe.Regridder(ds,ds_out,*args,**kwargs)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoSet.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum for all variables in dataset along specified dimension, applying specified weights</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>list</code></dt>
<dd>list of the dimensions along which to sum</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>None</code> or <code>list</code> or <code>dataarray</code></dt>
<dd>if None, no weight is applyed
if 'latitude' or 'depth', a weight is applyed as the cosine of the latitude or
the thickness of the layer
if dataarray :
input data are multiplied by this dataarray before summing</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>None</code> or <code>dataarray</code></dt>
<dd>mask to be applyed before summing</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>keyword arguments</code></dt>
<dd>any keyword arguments passe to the native xarray.sum function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>averaged</code></strong> :&ensp;<code>dataset</code></dt>
<dd>dataset with all variablessummed according to specified options</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<blockquote>
<p>data = xgeo.open_geodata('/home/user/lenapy/data/isas.nc')
avg = data.xgeo.sum(['latitude','longitude'],weights=['latitude'])</p>
</blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(self,*args,**kwargs):
    &#34;&#34;&#34;
    Returns the sum for all variables in dataset along specified dimension, applying specified weights
    
    Parameters
    ----------
    *args : list
        list of the dimensions along which to sum
    
    weights : None or list or dataarray
        if None, no weight is applyed
        if &#39;latitude&#39; or &#39;depth&#39;, a weight is applyed as the cosine of the latitude or 
                the thickness of the layer
        if dataarray :
                input data are multiplied by this dataarray before summing
    mask : None or dataarray
        mask to be applyed before summing
    **kwargs : keyword arguments
        any keyword arguments passe to the native xarray.sum function
        
    Returns
    -------
    averaged : dataset
        dataset with all variablessummed according to specified options
        
    Example
    -------
    &gt;&gt;&gt;data = xgeo.open_geodata(&#39;/home/user/lenapy/data/isas.nc&#39;)
    &gt;&gt;&gt;avg = data.xgeo.sum([&#39;latitude&#39;,&#39;longitude&#39;],weights=[&#39;latitude&#39;])
        
    &#34;&#34;&#34;             
    res={}
    for var in self._obj.data_vars:
        res[var]=self._obj[var].xgeo.sum(*args,**kwargs)
    return xr.Dataset(res)</code></pre>
</details>
</dd>
<dt id="lenapy.xGeo.GeoSet.to_datetime"><code class="name flex">
<span>def <span class="ident">to_datetime</span></span>(<span>self, input_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert dataset time format to standard pandas time format</p>
<h2 id="parameter">Parameter</h2>
<p>input_type : string
Can be 'frac_year' or '360_day'</p>
<h2 id="return">Return</h2>
<p>converted : dataset
new dataset with the time dimension in a standard pandas format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_datetime(self,input_type):
    &#34;&#34;&#34;
    Convert dataset time format to standard pandas time format
    
    Parameter
    ---------
    input_type : string
        Can be &#39;frac_year&#39; or &#39;360_day&#39;
        
    Return
    ------
    converted : dataset
        new dataset with the time dimension in a standard pandas format
    &#34;&#34;&#34;
    return to_datetime(self._obj,input_type)        </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lenapy" href="index.html">lenapy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lenapy.xGeo.open_geodata" href="#lenapy.xGeo.open_geodata">open_geodata</a></code></li>
<li><code><a title="lenapy.xGeo.open_mfgeodata" href="#lenapy.xGeo.open_mfgeodata">open_mfgeodata</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lenapy.xGeo.GeoArray" href="#lenapy.xGeo.GeoArray">GeoArray</a></code></h4>
<ul class="">
<li><code><a title="lenapy.xGeo.GeoArray.climato" href="#lenapy.xGeo.GeoArray.climato">climato</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.diff_3pts" href="#lenapy.xGeo.GeoArray.diff_3pts">diff_3pts</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.fill_time" href="#lenapy.xGeo.GeoArray.fill_time">fill_time</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.filter" href="#lenapy.xGeo.GeoArray.filter">filter</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.interp_time" href="#lenapy.xGeo.GeoArray.interp_time">interp_time</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.isosurface" href="#lenapy.xGeo.GeoArray.isosurface">isosurface</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.mean" href="#lenapy.xGeo.GeoArray.mean">mean</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.plot_timeseries_uncertainty" href="#lenapy.xGeo.GeoArray.plot_timeseries_uncertainty">plot_timeseries_uncertainty</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.regrid" href="#lenapy.xGeo.GeoArray.regrid">regrid</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.regridder" href="#lenapy.xGeo.GeoArray.regridder">regridder</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.sum" href="#lenapy.xGeo.GeoArray.sum">sum</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.to_datetime" href="#lenapy.xGeo.GeoArray.to_datetime">to_datetime</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.to_difgri" href="#lenapy.xGeo.GeoArray.to_difgri">to_difgri</a></code></li>
<li><code><a title="lenapy.xGeo.GeoArray.trend" href="#lenapy.xGeo.GeoArray.trend">trend</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lenapy.xGeo.GeoSet" href="#lenapy.xGeo.GeoSet">GeoSet</a></code></h4>
<ul class="two-column">
<li><code><a title="lenapy.xGeo.GeoSet.climato" href="#lenapy.xGeo.GeoSet.climato">climato</a></code></li>
<li><code><a title="lenapy.xGeo.GeoSet.fill_time" href="#lenapy.xGeo.GeoSet.fill_time">fill_time</a></code></li>
<li><code><a title="lenapy.xGeo.GeoSet.filter" href="#lenapy.xGeo.GeoSet.filter">filter</a></code></li>
<li><code><a title="lenapy.xGeo.GeoSet.interp_time" href="#lenapy.xGeo.GeoSet.interp_time">interp_time</a></code></li>
<li><code><a title="lenapy.xGeo.GeoSet.isosurface" href="#lenapy.xGeo.GeoSet.isosurface">isosurface</a></code></li>
<li><code><a title="lenapy.xGeo.GeoSet.mean" href="#lenapy.xGeo.GeoSet.mean">mean</a></code></li>
<li><code><a title="lenapy.xGeo.GeoSet.regrid" href="#lenapy.xGeo.GeoSet.regrid">regrid</a></code></li>
<li><code><a title="lenapy.xGeo.GeoSet.regridder" href="#lenapy.xGeo.GeoSet.regridder">regridder</a></code></li>
<li><code><a title="lenapy.xGeo.GeoSet.sum" href="#lenapy.xGeo.GeoSet.sum">sum</a></code></li>
<li><code><a title="lenapy.xGeo.GeoSet.to_datetime" href="#lenapy.xGeo.GeoSet.to_datetime">to_datetime</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>